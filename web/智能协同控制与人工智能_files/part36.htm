<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.2.1 集中式控制算法</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part35.htm">&lt; 上一个</a><span> | </span><a href="../%E6%99%BA%E8%83%BD%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part37.htm">下一个 &gt;</a></p><p class="s9" style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark32">3.2.1 </a><span class="s10">集中式控制算法</span></p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">1</span>）定义</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">多智能体集中式控制的算法是一种常用的协作和协调方法，它通过中央控制器来协调智能体之间的行动，以实现系统的整体目标。顾名思义，集中式算法本质上可以看做是集中式控制：仅有一个控制中心，有一个或多个执行器。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">集中式算法，系统的规模比较小时，集中式控制方案是一种高效的解决方式。通常应用在于环境变动较小，目标已明确且主体机器人功能突出的特殊情景，比如：疫情期间利用无人机和智能小车往小区派送物资等。</p><p style="padding-left: 122pt;text-indent: 0pt;text-align: left;"><span><img width="292" height="156" alt="IMG_256" title="IMG_256" src="Image_011.jpg"/></span></p><p class="s12" style="padding-top: 7pt;padding-left: 27pt;text-indent: 0pt;text-align: center;">图 <span class="s13">3.1 </span>集中式算法</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">如图 <span class="s11">3.1 </span>所示，该算法中有一个协调者，不管何时某个进程需要加入临界点区，它都要给协调者发出一条请求消息，表示对它希望加入下一个临界点区域的请求许可。若当前尚无其他进程在该临界区，协调者将发出许可进入的应答消息。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">（2）算法的优缺点 优点： </p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">如果没有进程，会处于永远待机状态(不会出现饿死的情况)，易于实现，因为每 次通过一个临界区域仅需要3个消息(请求、允许和释放)；不但可以用来管理临界区域，还能够进行更一般的资源分配。 </p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">缺点： </p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">如果协调者是一个单独的故障节点，一旦它崩溃了，整个网络系统也可能崩溃。 在通常情形下，一旦进程在发出请求之后被阻止了，则请求者将无法分辨“拒绝进入”和协调者操作系统已经崩溃这二者状况，因此在上述的二者状况下均不会有消息返回。另外，在体量很大的操作系统中，对于一个协调者会形成性能的瓶颈。</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part35.htm">&lt; 上一个</a><span> | </span><a href="../%E6%99%BA%E8%83%BD%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part37.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
