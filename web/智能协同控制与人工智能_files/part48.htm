<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.5.2 分类</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part47.htm">&lt; 上一个</a><span> | </span><a href="../%E6%99%BA%E8%83%BD%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part49.htm">下一个 &gt;</a></p><p class="s9" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark44">3.5.2 </a><span class="s10">分类</span></p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">1</span>）从学习方式分类</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">算法对一个问题建模的方式很多，可以基于经历、环境，或者任何我们称之为输入数据的东西。机器学习和人工智能的教科书通常会让你首先考虑算法能够采用什么方式学习。实际上，算法能够采取的学习方式或者说学习模型只有几种，下面我会一一说明。对机器学习算法进行分类是很有必要的事情，因为这迫使你思考输入数据的作用以及模型准备过程，从而选择一个最适用于你手头问题的算法。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">监督学习：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">输入数据被称为训练数据，并且每一个都带有标签，比如“广告<span class="s11">/</span>非广告”，或者当时的股票价格。通过训练过程建模，模型需要做出预测，如果预测出错会被修正。直到模型输出准确的结果，训练过程会一直持续。常用于解决的问题有分类和回归。常用的算法包括逻辑回归和 <span class="s11">BP </span>神经网络。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">常用的监督型学习方法举例</p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">K-<span class="p">近邻算法（</span>k-Nearest Neighbors<span class="p">，</span>KNN<span class="p">）</span></p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">K-<span class="p">近邻是一种分类算法，其思路是：如果一个样本与特征空间中的</span>K<span class="p">个最相似</span>(<span class="p">即</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 142%;text-align: justify;">特征空间中最邻近<span class="s11">)</span>的样本中的大多数属于某一个类别，则该样本也属于这个类别。<span class="s11">K</span>通常是不大于<span class="s11">20</span>的整数。<span class="s11">KNN</span>算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分类样本所属的类别。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 55pt;text-indent: 0pt;text-align: left;"><span><img width="492" height="295" alt="image" src="Image_018.png"/></span></p><p class="s12" style="padding-top: 1pt;padding-left: 181pt;text-indent: 0pt;text-align: left;">图 <span class="s13">3.6 K-</span>近邻算法计算流程</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">如上图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果 <span class="s11">K=3</span>，由于红色三角形所占比例为 <span class="s11">2/3</span>，绿色圆将被赋予红色三角形那个类，如果 <span class="s11">K=5</span>，由于 蓝色四方形比例为 <span class="s11">3/5</span>，因此绿色圆被赋予蓝色四方形类。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">算法的步骤为：</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">i</span>）计算测试数据与各个训练数据之间的距离；</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">ii</span>）按照距离的递增关系进行排序；</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">iii</span>）选取距离最小的<span class="s11">K </span>个点；</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">iv</span>）确定前 <span class="s11">K </span>个点所在类别的出现频率；</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 142%;text-align: left;">（<span class="s11">v</span>）返回前 <span class="s11">K </span>个点中出现频率最高的类别作为测试数据的预测分类。无监督学习：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">输入数据没有标签，输出没有标准答案，就是一系列的样本。无监督学习通过推 断输入数据中的结构建模。这可能是提取一般规律，可以是通过数学处理系统地减少 冗余，或者根据相似性组织数据。常用于解决的问题有聚类、降维和关联规则的学习。常用的算法包括 <span class="s11">Apriori </span>算法和 <span class="s11">K </span>均值算法。</p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Apriori <span class="p">的算法的应用</span></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">下面这个表格显示的是一个事务数据库 <span class="s11">D</span>，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><span><img width="456" height="196" alt="image" src="Image_019.jpg"/></span></p><p class="s12" style="padding-top: 6pt;padding-left: 201pt;text-indent: 0pt;text-align: justify;">图 <span class="s13">3.7 </span>事务数据库</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">其中最小支持度为 <span class="s11">50%</span>，最小置信度为 <span class="s11">70%</span>，求事务数据库中的频繁关联规则。</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">  <span class="s11">Apriori </span>算法的步骤如下所示<span class="s11">:</span></p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">（<span class="s11">1</span>）生成候选频繁 <span class="s11">1-</span>项目集 <span class="s11">C1={{</span>面包<span class="s11">}</span>，<span class="s11">{</span>牛奶<span class="s11">}</span>，<span class="s11">{</span>啤酒<span class="s11">}</span>，<span class="s11">{</span>花生<span class="s11">}</span>，<span class="s11">{</span>尿布<span class="s11">}}</span>。</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">2</span>）扫描事务数据库 <span class="s11">D</span>，计算 <span class="s11">C1 </span>中每个项目集在 <span class="s11">D </span>中的支持度。从事务数据库 <span class="s11">D </span>中可以得出每个项目集的支持数分别为 <span class="s11">3,3,3,1,2</span>，事务数据库 <span class="s11">D </span>的项目集总数为 <span class="s11">4</span>，因此可得出<span class="s11">C1 </span>中每个项目集的支持度分别为<span class="s11">75%</span>，<span class="s11">75%</span>，<span class="s11">75%</span>，<span class="s11">25%</span>，<span class="s11">50%</span>。根据最小支持度为 <span class="s11">50%</span>，可以得出频繁 <span class="s11">1-</span>项目集 <span class="s11">L1={{</span>面包<span class="s11">}</span>，<span class="s11">{</span>牛奶<span class="s11">}</span>，<span class="s11">{</span>啤酒<span class="s11">}</span>，<span class="s11">{</span>尿布<span class="s11">}}</span>。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: justify;">（<span class="s11">3</span>）根据 <span class="s11">L1 </span>生成候选频繁 <span class="s11">2-</span>项目集<span class="s11">C2={{</span>面包，牛奶<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒<span class="s11">}</span>，<span class="s11">{</span>面包，尿布<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒<span class="s11">}</span>，<span class="s11">{</span>牛奶，尿布<span class="s11">}</span>，<span class="s11">{</span>啤酒，尿布<span class="s11">}}</span>。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">4</span>）扫描事务数据库 <span class="s11">D</span>，计算 <span class="s11">C2 </span>中每个项目集在 <span class="s11">D </span>中的支持度。从事务数据库 <span class="s11">D</span>中可以得出每个项目集的支持数分别为<span class="s11">3,2,1,2,1,2</span>，事务数据库<span class="s11">D</span>的项目集总数为<span class="s11">4</span>，因此可得出<span class="s11">C2 </span>中每个项目集的支持度分别为 <span class="s11">75%</span>，<span class="s11">50%</span>，<span class="s11">25%</span>，<span class="s11">50%</span>，<span class="s11">25%</span>，<span class="s11">50%</span>。根据最小支持度为 <span class="s11">50%</span>，可以得出频繁 <span class="s11">2-</span>项目集<span class="s11">L2={{</span>面包，牛奶<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒<span class="s11">}</span>，<span class="s11">{</span>啤酒，尿布<span class="s11">}}</span>。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">5</span>）根据 <span class="s11">L2 </span>生成候选频繁 <span class="s11">3-</span>项目集<span class="s11">C3={{</span>面包，牛奶，啤酒<span class="s11">}</span>，<span class="s11">{</span>面包，牛奶，尿布<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒，尿布<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒，尿布<span class="s11">}}</span>，由于<span class="s11">C3 </span>中项目集<span class="s11">{</span>面包，牛奶，尿布<span class="s11">}</span>中的一个子集<span class="s11">{</span>牛奶，尿布<span class="s11">}</span>是 <span class="s11">L2 </span>中不存在的，因此可以去除。同理项目集<span class="s11">{</span>面包，啤酒，尿布<span class="s11">}</span>、<span class="s11">{</span>牛奶，啤酒，尿布<span class="s11">}</span>也可去除。因此 <span class="s11">C3={</span>面包，牛奶，啤酒<span class="s11">}</span>。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">6</span>）扫描事务数据库 <span class="s11">D</span>，计算 <span class="s11">C3 </span>中每个项目集在 <span class="s11">D </span>中的支持度。从事务数据库 <span class="s11">D </span>中可以得出每个项目集的支持数分别为 <span class="s11">2</span>，事务数据库 <span class="s11">D </span>的项目集总数为 <span class="s11">4</span>，因此可得出<span class="s11">C2 </span>中每个项目集的支持度分别为 <span class="s11">50%</span>。根据最小支持度为 <span class="s11">50%</span>，可以得出频繁 <span class="s11">3-</span>项目集 <span class="s11">L3={{</span>面包，牛奶，啤酒<span class="s11">}}</span>。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">7</span>）<span class="s11">L ={{</span>面包<span class="s11">}</span>，<span class="s11">{</span>牛奶<span class="s11">}</span>，<span class="s11">{</span>啤酒<span class="s11">}</span>，<span class="s11">{</span>尿布<span class="s11">}</span>，<span class="s11">{</span>面包，牛奶<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒<span class="s11">}</span>，<span class="s11">{</span>啤酒，尿布<span class="s11">}</span>，<span class="s11">{</span>面包，牛奶，啤酒<span class="s11">}}</span>。</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">8</span>）我们只考虑项目集长度大于 <span class="s11">1 </span>的项目集，例如<span class="s11">{</span>面包，牛奶，啤酒<span class="s11">}</span>，它的所有非真子集<span class="s11">{</span>面包<span class="s11">}</span>，<span class="s11">{</span>牛奶<span class="s11">}</span>，<span class="s11">{</span>啤酒<span class="s11">}</span>，<span class="s11">{</span>面包，牛奶<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒<span class="s11">}</span>，分别计算关联规则<span class="s11">{</span>面包<span class="s11">}</span>—<span class="s11">&gt;{</span>牛奶，啤酒<span class="s11">}</span>，<span class="s11">{</span>牛奶<span class="s11">}</span>—<span class="s11">&gt;{</span>面包，啤酒<span class="s11">}</span>，<span class="s11">{</span>啤酒<span class="s11">}</span>—<span class="s11">&gt;{</span>面</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 142%;text-align: justify;">包，牛奶<span class="s11">}</span>，<span class="s11">{</span>面包，牛奶<span class="s11">}</span>—<span class="s11">&gt;{</span>啤酒<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒<span class="s11">}</span>—<span class="s11">&gt;{</span>牛奶<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒<span class="s11">}</span>—<span class="s11">&gt;{</span>面包<span class="s11">}</span>的置信度，其值分别为 <span class="s11">67%</span>，<span class="s11">67%</span>，<span class="s11">67%</span>，<span class="s11">67%</span>，<span class="s11">100%</span>，<span class="s11">100%</span>。由于最小置信度为 <span class="s11">70%</span>，可得<span class="s11">}</span>，<span class="s11">{</span>面包，啤酒<span class="s11">}</span>—<span class="s11">&gt;{</span>牛奶<span class="s11">}</span>，<span class="s11">{</span>牛奶，啤酒<span class="s11">}</span>—<span class="s11">&gt;{</span>面包<span class="s11">}</span>为频繁关联规则。也就是说买面包和啤酒的同时肯定会买牛奶，买牛奶和啤酒的同时也是会买面包。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: justify;">由这个例子可以看出 <span class="s11">Apriori </span>主要是根据 最小支持度来判断，最后逐步递进。半监督学习：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">半监督学习的输入数据包含带标签和不带标签的样本。半监督学习的情形是，有一个预期中的预测，但模型必须通过学习结构整理数据从而做出预测。常用于解决的问题是分类和回归。常用的算法是所有对无标签数据建模进行预测的算法（即无监督学习）的延伸。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">（<span class="s11">2</span>）从功能角度分类</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">研究人员常常通过功能相似对算法进行分类。例如，基于树的方法和基于神经网 络的方法。这种方法也是我个人认为最有用的分类方法。不过，这种方法也并非完美，比如学习矢量量化（<span class="s11">LVQ</span>），就既可以被归为神经网络方法，也可以被归为基于实例 的方法。此外，像回归和聚类，就既可以形容算法，也可以指代问题。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">回归算法：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">回归分析是研究自变量和因变量之间关系的一种预测模型技术。这些技术应用于预测时间序列模型和找到变量之间关系。回归分析也是一种常用的统计学方法，经由统计机器学习融入机器学习领域。“回归”既可以指算法也可以指问题，因此在指代的时候容易混淆。实际上，回归就是一个过程而已。常用的回归算法包括：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">普通最小二乘回归（<span class="s11">OLSR</span>）线性回归、逻辑回归、逐步回归、多元自适应回归样条法（<span class="s11">MARS</span>）、局部估计平滑散点图（<span class="s11">LOESS</span>）。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">基于实例的学习算法：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">基于实例的学习通过训练数据的样本或事例建模，这些样本或事例也被视为建模所必需的。这类模型通常会建一个样本数据库，比较新的数据和数据库里的数据，通过这种方式找到最佳匹配并做出预测。换句话说，这类算法在做预测时，一般会使用相似度准则，比对待预测的样本和原始样本之间的相似度，再做出预测。因此，基于实例的方法也被称之为赢家通吃的方法（<span class="s11">winner-take-all</span>）和基于记忆的学习（<span class="s11">memory- based learning</span>）。常用的基于实例的学习算法包括：<span class="s11">k-</span>邻近算法（<span class="s11">kNN</span>）、学习矢量量</p><p style="padding-top: 4pt;padding-left: 29pt;text-indent: -24pt;line-height: 141%;text-align: left;">化算法（<span class="s11">LVQ</span>）、自组织映射算法（<span class="s11">SOM</span>）、局部加权学习算法（<span class="s11">LWL</span>）正则化算法：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">正则化算法背后的思路是，参数值比较小的时候模型更加简单。对模型的复杂度会有一个惩罚值，偏好简单的、更容易泛化的模型，正则化算法可以说是这种方法的延伸。我把正则化算法单独列出来，原因就是它们十分受欢迎、功能强大，而且能够对其他方法进行简单的修饰。常用的正则化算法包括：</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">（<span class="s11">1</span>）岭回归</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">2</span>）<span class="s11">LASSO </span>算法</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">3</span>）<span class="s11">Elastic Net</span></p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">4</span>）最小角回归算法（<span class="s11">LARS</span>）</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">5</span>）决策树算法</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">决策树算法的目标是根据数据属性的实际值，创建一个预测样本目标值的模型。训练时，树状的结构会不断分叉，直到作出最终的决策。也就是说，预测阶段模型会选择路径进行决策。决策树常被用于分类和回归。决策树一般速度快，结果准，因此也属于最受欢迎的机器学习算法之一。常用的决策树算法包括：</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">（<span class="s11">1</span>）分类和回归树（<span class="s11">CART</span>）</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">2</span>）<span class="s11">ID3 </span>算法</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">3</span>）<span class="s11">C4.5 </span>算法和 <span class="s11">C5.0 </span>算法（它们是一种算法的两种不同版本）</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">4</span>）<span class="s11">CHAID </span>算法</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">5</span>）单层决策树</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">6</span>）<span class="s11">M5 </span>算法</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">7</span>）条件决策树</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">8</span>）贝叶斯算法</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">贝叶斯方法指的是那些明确使用贝叶斯定理解决分类或回归等问题的算法。常用的贝叶斯算法包括：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">朴素贝叶斯算法、高斯朴素贝叶斯算法、多项式朴素贝叶斯算法、 <span class="s11">AODE </span>算法、贝叶斯信念网络（<span class="s11">BBN</span>）、贝叶斯网络（<span class="s11">BN</span>）</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">聚类算法：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">聚类跟回归一样，既可以用来形容一类问题，也可以指代一组方法。聚类方法通常涉及质心（<span class="s11">centroid-based</span>）或层次（<span class="s11">hierarchal</span>）等建模方式，所有的方法都与数据固有的结构有关，目标是将数据按照它们之间共性最大的组织方式分成几组。换句话说，算法将输入样本聚成围绕一些中心的数据团，通过这样的方式发现数据分布结构</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 141%;text-align: justify;">中的规律。常用的聚类算法包括：<span class="s11">K-</span>均值、<span class="s11">K-</span>中位数、<span class="s11">EM </span>算法、分层聚类算法关联规则学习。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">关联规则学习在数据不同变量之间观察到了一些关联，算法要做的就是找出最能描述这些关系的规则，也就是获取一个事件和其他事件之间依赖或关联的知识。常用的关联规则算法有：<span class="s11">Apriori </span>算法、<span class="s11">Eclat </span>算法、人工神经网络。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">人工神经网络是一类受生物神经网络的结构及<span class="s11">/</span>或功能启发而来的模型。它们是一类常用于解决回归和分类等问题的模式匹配，不过，实际上是一个含有成百上千种算法及各种问题变化的子集。人工神经网络指的是更加经典的感知方法。常用的人工神经网络包括：反向传播算法（<span class="s11">BP </span>神经网络）<span class="s11">Hopfield </span>网络。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">径向基函数网络（<span class="s11">RBFN</span>）、深度学习算法：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">深度学习算法是人工神经网络的升级版，充分利用廉价的计算力。近年来，深度学习得到广泛应用，尤其是语音识别、图像识别。深度学习算法会搭建规模更大、结构更复杂的神经网络，正如上文所说，很多深度学习方法都涉及半监督学习问题，这种问题的数据一般量极大，而且只有很少部分带有标签。常用的深度学习算法包括：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: justify;">深度玻尔兹曼机（<span class="s11">DBM</span>）、深度信念网络（<span class="s11">DBN</span>）、卷积神经网络（<span class="s11">CNN</span>）、栈式自编码算法（<span class="s11">Stacked Auto-Encoder</span>）。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">降维算法：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">降维算法和聚类有些类似，也是试图发现数据的固有结构。但是，降维算法采用的是无监督学习的方式，用更少（更低维）的信息进行总结和描述。降维算法可以监督学习的方式，被用于多维数据的可视化或对数据进行简化处理。很多降维算法经过修改后，也被用于分类和回归的问题。常用的降维算法包括：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">（<span class="s11">1</span>）主成分分析法（<span class="s11">PCA</span>）、主成分回归（<span class="s11">PCR</span>）、偏最小二乘回归（<span class="s11">PLSR</span>）、萨蒙映射；</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">（<span class="s11">2</span>）多维尺度分析法（<span class="s11">MDS</span>）、投影寻踪法（<span class="s11">PP</span>）、线性判别分析法（<span class="s11">LDA</span>、混合判别分析法（<span class="s11">MDA</span>）、二次判别分析法（<span class="s11">QDA</span>）、灵活判别分析法（<span class="s11">Flexible Discriminant Analysis</span>，<span class="s11">FDA</span>）。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">模型融合算法：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">模型融合算法将多个简单的、分别单独训练的弱机器学习算法结合在一起，这些弱机器学习算法的预测以某种方式整合成一个预测。通常这个整合后的预测会比单独的预测要好一些。构建模型融合算法的主要精力一般用于决定将哪些弱机器学习算法以什么样的方式结合在一起。模型融合算法是一类非常强大的算法。常用的模型融合增强方法包括：</p><p class="s11" style="padding-top: 4pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: justify;">Boosting<span class="p">、</span>Bagging<span class="p">、</span>AdaBoost<span class="p">、堆叠泛化（混合）、</span>GBM <span class="p">算法、</span>GBRT <span class="p">算法、随机森林等。</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part47.htm">&lt; 上一个</a><span> | </span><a href="../%E6%99%BA%E8%83%BD%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part49.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
