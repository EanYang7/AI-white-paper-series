<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.6.2 分类</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part50.htm">&lt; 上一个</a><span> | </span><a href="../%E6%99%BA%E8%83%BD%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part52.htm">下一个 &gt;</a></p><p class="s9" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark47">3.6.2 </a><span class="s10">分类</span></p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">优化算法有很多，关键是针对不同的优化问题。例如可行解变量的取值（连续还 是离散）、目标函数和约束条件的复杂程度（线性还是非线性）等，应用不同的算法。</p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">1<span class="p">、对于连续和线性等较简单的问题，可以选择一些经典算法，如梯度、</span>Hessian</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">矩阵、拉格朗日乘数、单纯形法、梯度下降法等。</p><p class="s11" style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">2<span class="p">、对于更复杂的问题，则可考虑用一些智能优化算法，如遗传算法和蚁群算法，此外还包括模拟退火、禁忌搜索、粒子群算法等 。</span></p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">采用最优化算法解决实际问题主要分为下列两步：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">（<span class="s11">1</span>）建立数学模型。对可行方案进行编码（变量），约束条件以及目标函数的构造。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">（<span class="s11">2</span>）最优值的搜索策略。在可行解（约束条件下）搜索最优解的方法，有穷举、随机和启发式搜索方法。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">最优化算法有三要素：变量（<span class="s11">Decision Variable</span>）、约束条件（<span class="s11">Constraints</span>）和目标函数（<span class="s11">Objective function</span>）。最优化算法，其实就是一种搜索过程或规则，它是基于某种思想和机制，通过一定的途径或规则来得到满足用户要求的问题的解。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">优化问题相关算法有如下分类：</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（<span class="s11">1</span>）精确算法（绝对最优解）</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">精确算法包括线性规划、动态规划、整数规划和分支定界法等运筹学中的传统算法，其算法计算复杂性一般很大，只适合于求解小规模问题，在工程中往往不实用。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">（<span class="s11">2</span>）启发式算法（近似算法）</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">启发式方法指人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时，利用过去的经验，选择已经行之有效的方法，而不是系统地、以</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">确定的步骤去寻求答案。</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">领域搜索算法。从任一解出发，对其领域的不断搜索和当前解的替换来实现优化。根据搜索行为，它又可分为局部搜索法和指导性搜索法。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">局部领域搜索法（也称爬山法）。以局部优化策略在当前解的领域中贪婪搜索，如只接受优于当前解的状态作为下一当前解的爬山法，接受当前邻域中的最好解作为下一当前解的最陡下降法等。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">指导性搜索法。利用一些指导规则来指导整个解空间中优良解的探索，如 <span class="s11">SA</span>、 <span class="s11">GA</span>、<span class="s11">EP</span>、<span class="s11">ES </span>和 <span class="s11">TS </span>等<span class="s11">.</span></p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">个体启发（寻找相对最优）</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">特点：每次输出的是相同的。从一个解开始，寻找最优，易陷入局部最优。爬山算法：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">算法思想：从当前的节点开始，和周围的邻居节点的值进行比较。如果当前节点是最大的，那么返回当前节点，作为最大值<span class="s11">(</span>即山峰最高点<span class="s11">)</span>；反之就用最高的邻居节点替换当前节点，从而实现向山峰的高处攀爬的目的。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">其实就是，在初始值的附近，找到最大的一个。优点：</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">容易理解，容易实现，具有较强的通用性；局部开发能力强，收敛速度很快缺点：</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">全局开发能力弱，只能搜索到局部最优解；搜索结果完全依赖于初始解和邻域的映射关系。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">禁忌算法<span class="s11">(Tabu Search</span>，<span class="s11">TS)</span>：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">基本思想：基于爬山算法的改进，标记已经解得的局部最优解或求解过程，并在进一步的迭代中避开这些局部最优解或求解过程。局部搜索的缺点在于，太过于对某一局部区域以及其邻域的搜索，导致一叶障目。为了找到全局最优解，禁忌搜索就是对于找到的一部分局部最优解，有意识地避开它，从而或得更多的搜索区域。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">特点：</p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">1 <span class="p">避免在搜索过程中的循环；</span></p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">2 <span class="p">只进不退的原则，通过禁忌表实现；</span></p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">3 <span class="p">不以局部最优作为停止准则；</span></p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 142%;text-align: left;">4 <span class="p">邻域选优的规则模拟了人类的记忆功能；禁忌表：用于防止搜索出现循环。</span></p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">记录前若干步走过的点、方向或目标值，禁止返回。</p><p style="padding-top: 4pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">表是动态更新的。</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">表的长度称为 <span class="s11">Tabu-Size</span>。</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">禁忌表的主要指标（两项指标）。</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">禁忌对象：禁忌表中被禁的那些变化元素。禁忌长度：禁忌的步数。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">禁忌对象（三种变化）：</p><p style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 142%;text-align: left;">以状态本身或者状态的变化作为禁忌对象。以状态分量以及分量的变化作为禁忌对象。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 15pt;text-align: left;">采用类似的等高线做法，以目标值变化作为禁忌对象。</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">禁忌长度：可以是一个固定的常数<span class="s11">(T=c),</span>也可以是动态变化的，可按照某种规则或公式在区间内变化。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">禁忌长度过短，一旦陷入局部最优点，出现循环无法跳出；</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">禁忌长度过长，候选解全部被禁忌，造成计算时间较大，也可能造成计算无法继续下去。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">贪婪算法</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快地求得更好的解。当达到算法中的某一步不能再继续前进时，算法停止。</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 142%;text-align: left;">举列：单源路径中的 <span class="s11">Djikstra </span>算法求 <span class="s11">A </span>到其他节点的最短路径：</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">基本都要先排序，从排序的开始那个依次判断，符合就留下不符合就去掉。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 101pt;text-indent: 0pt;text-align: left;"><span><img width="368" height="205" alt="image" src="Image_020.jpg"/></span></p><p class="s12" style="padding-top: 6pt;padding-left: 208pt;text-indent: 0pt;text-align: left;">图 <span class="s13">3.8 </span>最短路径</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">从 <span class="s11">A </span>到其他节点的路径长度队列 <span class="s11">Queue</span>，数组 <span class="s11">visited </span>用于记录已保存最短路径的节点，数组 <span class="s11">res </span>用于记录节点 <span class="s11">A </span>到其他节点的最短路径。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">开始时，<span class="s11">Queue </span>中只有 <span class="s11">A </span>节点，三组数据如下：</p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Queue<span class="p">：</span>[(A, 0)] <span class="p">起始节点为 </span>A<span class="p">，</span>A <span class="p">到 </span>A <span class="p">的距离为 </span>0</p><p class="s11" style="padding-top: 4pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">visited<span class="p">：</span>[true, false,false,false,false] A <span class="p">节点是已经访问过的节点，是 </span>true<span class="p">，其他节点是 </span>false</p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">res<span class="p">：</span>[0<span class="p">，∞，∞，∞，∞</span>] A <span class="p">到自己的距离是 </span>0<span class="p">，到其他节点的距离目前是∞</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 9pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">将以 <span class="s11">A </span>为起点的路径加入到 <span class="s11">Queue </span>中，<span class="s11">2 </span>和 <span class="s11">4 </span>是节点 <span class="s11">D </span>和 <span class="s11">B </span>的路径权重：</p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Queue<span class="p">：</span>[(D, 2), (B, 4)]</p><p class="s11" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">visited<span class="p">：</span>[true, false,false,false,false] res<span class="p">：</span>[0<span class="p">，∞，∞，∞，∞</span>]</p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">在 <span class="s11">Queue </span>中，路径最短的是 <span class="s11">D</span>，取出 <span class="s11">D</span>，更新三组数据： <span class="s11">Queue</span>：<span class="s11">[(B, 3), (C, 3), (E, 9)]</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">因为<span class="s11">A-D-B </span>的路径权重为 <span class="s11">3 </span>小于<span class="s11">A-B </span>的路径权重 <span class="s11">4</span>，所以更新一下<span class="s11">B </span>的路径权重。</p><p class="s11" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;line-height: 143%;text-align: left;">visited:[true,false,false,true,false] res: [0,<span class="p">∞</span>, <span class="p">∞</span>,2,<span class="p">∞</span>]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 139%;text-align: left;">取出 <span class="s11">B</span>，更新三组数据： <span class="s11">Queue: [(C,3), (E, 9)]</span></p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 143%;text-align: left;">visited: [true,true,false,true,false] res: [0,3, <span class="p">∞</span>,2, <span class="p">∞</span>]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 142%;text-align: left;">取出 <span class="s11">C</span>，更新三组数据： <span class="s11">Queue</span>：<span class="s11">[(E, 6)]</span></p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 143%;text-align: left;">visited: [true,true,true,true,false] res: [0,3, 3,2, <span class="p">∞</span>]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">取出 <span class="s11">E</span>，更新三组数据： <span class="s11">Queue</span>：<span class="s11">[]</span></p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 140%;text-align: left;">visited: [true,true,true,true,true] res: [0,3, 3,2, 6]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;line-height: 141%;text-align: left;">至此，<span class="s11">Queue </span>队列空，计算过程结束。模拟退火<span class="s11">(simulated annealing</span>，<span class="s11">SA)</span>：</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">模拟退火算法作为局部搜索算法的扩展，在每一次修改模型的过程中，随机产生</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 142%;text-align: justify;">一个新的状态模型，然后以一定的概率选择邻域中能量值大的状态。这种接受新模型的方式使其成为一种全局最优算法，并得到理论证明和实际应用的验证。<span class="s11">SA </span>虽然在寻优能力上不容置疑，但它是以严密的退火计划为保证的，具体地讲，就是足够高的初始温度、缓慢的退火速度、大量的迭代次数及同一温度下足够的扰动次数。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">用兔子的故事来说：兔子喝醉了。随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，渐渐清醒了并朝它踏过的最高方向跳去。这就是模拟退火。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: left;">其实就是，先用初始值进行随机更新，记录每次更新的值，最后取历史记录中最大的值。</p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">参考：模拟退火算法、群体智能（全局最优）。</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 141%;text-align: justify;">类别：粒子群算法<span class="s11">(PSO)</span>、蚁群算法<span class="s11">(ACO)</span>、人工蜂群算法<span class="s11">(ABC)</span>、人工鱼群算法 <span class="s11">(AFSA)</span>、混洗蛙跳算法<span class="s11">(SFLA)</span>、烟花算法<span class="s11">(FWA)</span>、细菌觅食优化<span class="s11">(BFO)</span>、萤火虫算法 <span class="s11">(FA)</span></p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">特点：全局寻优每次的解都不同时间较长智能计算包括：</p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: left;">进化算法（<span class="s11">EC</span>）：如遗传算法、模糊逻辑群智能<span class="s11">(SI)</span>算法、人工免疫系统<span class="s11">(AIS)</span>人工神经网络<span class="s11">(ANN)</span>。</p><p style="padding-left: 5pt;text-indent: 24pt;line-height: 142%;text-align: justify;">智能协同控制控制算法最初在多智能体研究领域提出并广泛应用，常用于多智能体的编队控制、趋同控制、蜂拥控制以及聚集等问题。近几年，协同性控制尤其里面的优化控制算法中的 <span class="s11">ADP</span>（自适应动态规划算法）方法应用到了在多智能体优化控制和电力系统的方向。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s6" style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark48">4.1 </a><span class="s7">引言</span><a name="bookmark49">&zwnj;</a></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part50.htm">&lt; 上一个</a><span> | </span><a href="../%E6%99%BA%E8%83%BD%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part52.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
