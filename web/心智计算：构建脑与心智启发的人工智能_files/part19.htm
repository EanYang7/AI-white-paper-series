<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.4 SOAR</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part18.htm">&lt; 上一个</a><span> | </span><a href="../%E5%BF%83%E6%99%BA%E8%AE%A1%E7%AE%97%EF%BC%9A%E6%9E%84%E5%BB%BA%E8%84%91%E4%B8%8E%E5%BF%83%E6%99%BA%E5%90%AF%E5%8F%91%E7%9A%84%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part20.htm">下一个 &gt;</a></p><p class="s9" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark16">3.4 SOAR</a><a name="bookmark24">&zwnj;</a></p><p class="s8" style="padding-top: 7pt;padding-bottom: 2pt;padding-left: 5pt;text-indent: 27pt;line-height: 139%;text-align: left;">1987 <span class="p">年</span>, Allen Newell <span class="p">和</span>John Laird<span class="p">、</span>Paul Rosenbloom <span class="p">提出了一 个通用解题结构</span>SOAR<span class="s11">[20]</span><span class="p">：即状态 </span>State<span class="p">，算子 </span>Operator <span class="p">和结果 </span>Result, <span class="p">表示弱方法的基本原理是不断地将算子作用于状态，以得到新的结果。如图 </span>3-4 <span class="p">所示，产生式记忆器和决策过程形成处理结构。产生式记忆 器中存放产生式规则</span>,<span class="p">它进行记忆搜索及控制决策：首先，所有规则被 并行地用于工作记忆器</span>, <span class="p">判断优先权</span>, <span class="p">决定哪部分语境进行改变以及 如何改变；进一步地，决策阶段决定语境栈中要改变的部分和对象。</span></p><p style="padding-left: 130pt;text-indent: 0pt;text-align: left;"><span><img width="265" height="232" alt="?" title="?" src="Image_005.gif"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 32pt;text-indent: 0pt;text-align: center;">图 3-4 SOAR 的框图<span class="s21">[20]</span><span class="s22"> </span></p><p class="s8" style="padding-top: 6pt;padding-left: 36pt;text-indent: 0pt;text-align: center;">SOAR <span class="p">中的所有成分统称为对象，这些成分包括状态、状态空间、</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 139%;text-align: left;">算子和目标。在 <span class="s8">SOAR </span>问题求解过程中，大体上是一个分析<span class="s8">-</span>决策<span class="s8">-</span>行动的三部曲。</p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;">（<span class="s8">1</span>） 分析阶段</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">输入：库中的对象；</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">任务：从库中选出对象加入当前环境；</p><p style="padding-top: 7pt;padding-left: 33pt;text-indent: 41pt;line-height: 139%;text-align: left;">增加有关当前环境中对象的信息角色；控制<span class="s8">: </span>反复执行，直至完成。</p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;">（<span class="s8">2</span>） 决策阶段</p><p style="padding-top: 7pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">输入：库中的对象；</p><p style="padding-top: 7pt;padding-left: 75pt;text-indent: -42pt;line-height: 139%;text-align: left;">任务：赞成，或反对，或否决库中的对象。选择一个新的对象，用它取代当前环境中的同类对象。</p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;">控制：赞成和反对同时进行。</p><p style="padding-top: 7pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">（<span class="s8">3</span>） 执行阶段</p><p style="padding-top: 7pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">输入：当前状态和当前算子；</p><p style="padding-top: 7pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">任务：把当前算子应用于当前状态。</p><p style="padding-top: 7pt;padding-left: 75pt;text-indent: 0pt;line-height: 139%;text-align: left;">如果因此而产生一个新状态，则把新状态加入库中，并用它取代原来的状态。</p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">控制：这是一个基本动作，不可再分。</p><p class="s8" style="padding-top: 7pt;padding-left: 6pt;text-indent: 27pt;line-height: 139%;text-align: left;">SOAR <span class="p">系统运行过程中，在分析阶段</span>, <span class="p">任务是尽量扩大有关当前对象的知识，以便在决策阶段使用。决策阶段主要是进行投票，投票由规则来做，它可以看成是同时进行的，各投票者之间不传递信息，不互相影响。在执行阶段，如果当前环境的每个部分都有定义，则用当前算子作用于当前状态。若作用成功，则用新状态代替旧状态，算子部分成为无定义，重新执行分析阶段。</span></p><p style="padding-left: 6pt;text-indent: 27pt;line-height: 139%;text-align: justify;">每当问题求解器不能顺利求解时，系统就进入劝告问题空间请求专家指导。专家以两种方式给以指导。一种是直接指令方式，这时系统展开所有的算子以及当时的状态。由专家根据情况指定一个算子。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 139%;text-align: justify;">指定的算子要经过评估，即由系统建立一个子目标，用专家指定的算子求解。如果有解，则评估确认该算子是可行的，系统便接受该指令，并返回去求证用此算子求解的过程为何是正确的。总结求证过程，从而学到使用专家劝告的一般条件，即组块。</p><p style="padding-left: 6pt;text-indent: 21pt;line-height: 139%;text-align: justify;">另一种是间接的简单直观形式，这时系统先把原问题按语法分解成树结构的内部表示<span class="s8">, </span>并附上初始状态，然后请求专家劝告。专家通过外部指令给出一个直观的简单问题，它应该与原问题近似，系统建立一个子目标来求解这个简单问题。求解完后就得到算子序列，学习机制通过每个子目标求解过程学到组块。用组块直接求解原问题，不再需要请求指导。</p><p class="s8" style="padding-left: 5pt;text-indent: 27pt;line-height: 139%;text-align: left;">SOAR <span class="p">系统中的组块学习机制是学习的关键。它使用工作记忆 单元来收集条件并构造组块。当系统为评估专家的劝告，或为求解简 单问题而建立一个子目标时</span>, <span class="p">首先将当时的状态存入工作记忆单元。当子目标得到解以后，系统从工作记忆单元中取出子目标的初始状态，删去与算子或求解简单问题所得出的解算子作为结论动作。由此生成 产生式规则，这就是组块。如果子目标与原问题的子目标充分类似</span>, <span class="p">组块就会被直接应用到原问题上</span>, <span class="p">学习策略就把在一个问题上学到 的经验用到另一个问题上。</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part18.htm">&lt; 上一个</a><span> | </span><a href="../%E5%BF%83%E6%99%BA%E8%AE%A1%E7%AE%97%EF%BC%9A%E6%9E%84%E5%BB%BA%E8%84%91%E4%B8%8E%E5%BF%83%E6%99%BA%E5%90%AF%E5%8F%91%E7%9A%84%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">内容</a><span> | </span><a href="part20.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
