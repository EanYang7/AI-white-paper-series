<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.2.4 归结原理</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part43.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part45.htm">下一个 &gt;</a></p><p class="s14" style="padding-top: 2pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><a name="bookmark44">2.2.4 </a><span class="h4">归结原理</span></p><p class="s10" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">2.2.4.1 <span class="s37">基子句的归结原理</span></p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">对任意两个基子句 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span><span class="p">，如果 </span>C<span class="s35">1</span> <span class="p">中存在文字 </span>L<span class="s35">1</span><span class="p">，</span>C<span class="s35">2</span> <span class="p">中存在文字 </span>L<span class="s35">2</span><span class="p">，且 </span>L<span class="s35">1</span>=<span class="s23"></span>L<span class="s35">2</span><span class="p">，则从 </span>C<span class="s35">1</span><span class="p">，</span>C<span class="s35">2</span> <span class="p">中分别删除 </span>L<span class="s35">1</span><span class="p">，</span>L<span class="s35">2</span><span class="p">，将 </span>C<span class="s35">1</span><span class="p">，</span>C<span class="s35">2</span> <span class="p">的剩余部分析取起来构成子句，称为 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">的归结式。例如， </span>C<span class="s35">1</span>=<span class="s23"></span>P<span class="s23"></span>Q<span class="s23"></span>R<span class="p">，</span>C<span class="s35">2</span>=<span class="s23"></span>Q<span class="s23"></span>S<span class="p">，于是 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">的归结式为</span><span class="s23"></span>P<span class="s23"></span>R<span class="s23"></span>S<span class="p">。设 </span>C<span class="s35">1</span><span class="p">， </span>C<span class="s35">2</span> <span class="p">是两个基子句，则 </span>C<span class="s35">1</span><span class="p">，</span>C<span class="s35">2</span> <span class="p">的归结式</span>C <span class="p">是 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">的逻辑结果。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">设 </span>S  <span class="p">是子句集，从 </span>S  <span class="p">推出子句 </span>C  <span class="p">的演绎是有限子句序列： </span>C<span class="s35">1</span>,C<span class="s35">2</span>,...,C<span class="s35">k</span><span class="p">。其中</span>C<span class="s35">i</span><span class="p">或者是</span>S <span class="p">中子句，或者是</span>C<span class="s35">j</span><span class="p">和</span>C<span class="s35">r</span><span class="p">的归结式（</span>j&lt;i,r&lt;i<span class="p">）；并且 </span>C<span class="s35">k</span>=C<span class="p">。从 </span>S <span class="p">推出空子句</span><span class="s38"></span><span class="p">的演绎称为反驳，或称为 </span>S <span class="p">的一个证明。从子句集</span>S <span class="p">演绎出子句</span>C<span class="p">，是指存在一个从 </span>S <span class="p">推出</span>C <span class="p">的演绎。</span></p><p class="s10" style="padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">例 </span>2<span class="p">，</span>S={P<span class="s23"></span>Q,<span class="s23"></span>P<span class="s23"></span>Q,P<span class="s23"></span>Q,<span class="s23"></span>P<span class="s23"></span>Q}</p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>1<span class="p">）</span>P<span class="s23"></span>Q<span class="p">；</span></p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>2<span class="p">）</span><span class="s23"></span>P<span class="s23"></span>Q<span class="p">；</span></p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>3<span class="p">）</span>P<span class="s23"></span>Q<span class="p">；</span></p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>4<span class="p">）</span><span class="s23"></span>P<span class="s23"></span>Q<span class="p">；</span></p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">5</span>）<span class="s10">Q                              </span>由（<span class="s10">1</span>）<span class="s10">,</span>（<span class="s10">2</span>）；</p><p style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">6</span>）<span class="s23"></span><span class="s10">Q                            </span>由（<span class="s10">3</span>）<span class="s10">,</span>（<span class="s10">4</span>）；</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">7</span>）<span class="s38"></span><span class="s10">                              </span>由（<span class="s10">5</span>）<span class="s10">,</span>（<span class="s10">6</span>）。</p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">如果基子句集 <span class="s10">S </span>是不可满足的，则存在从 <span class="s10">S </span>推出空子句的归结演绎。</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">2.2.4.2 <span class="s37">一般子句的归结原理</span></p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">提升引理：如果 </span>C<span class="s35">1</span>’<span class="p">和 </span>C<span class="s35">2</span>’<span class="p">分别是子句 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">的例，</span>C’<span class="p">是 </span>C<span class="s35">1</span>’<span class="p">和 </span>C<span class="s35">2</span>’<span class="p">的归结式，则存在 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">的一个归结式 </span>C<span class="p">，使 </span>C’<span class="p">是 </span>C <span class="p">的例。根据 </span>Herbrand <span class="p">定理和提升引理，可以证明一阶逻辑中归结原理的完备性：若子句集 </span>S <span class="p">是不可满足的，则存在从 </span>S <span class="p">推出空子句的归结演绎。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">例 <span class="s10">3</span>：已知某些病人喜欢所有的医生，没有一个病人喜欢任意一个骗子。证明任意一个医生都不是骗子。</p><p style="text-indent: 0pt;text-align: right;">证：令 <span class="s10">P(x): x </span>是病人</p><p class="s10" style="padding-top: 7pt;text-indent: 0pt;text-align: right;">D(x): x <span class="p">是医生</span></p><p class="s10" style="padding-top: 7pt;text-indent: 0pt;text-align: right;">Q(x): x <span class="p">是骗子</span></p><p class="s10" style="padding-top: 7pt;text-indent: 0pt;text-align: right;">L(x,y): x <span class="p">喜欢 </span>y</p><p class="s10" style="padding-top: 6pt;padding-left: 76pt;text-indent: 0pt;text-align: left;">A<span class="s35">1</span>: <span class="s23"></span>x(P(x)<span class="s23"></span>y(D(y)<span class="s23"></span>L(x,y)))</p><p class="s10" style="padding-top: 7pt;padding-left: 76pt;text-indent: 0pt;line-height: 146%;text-align: left;">A<span class="s35">2</span>: <span class="s23"></span>x(P(x)<span class="s23"></span>y(Q(y)<span class="s23"></span>L(x,y))) B: <span class="s23"></span>x(D(x)<span class="s23"></span>Q(x))</p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;"><span class="p">要证明公式 </span>A<span class="s35">1</span><span class="s23"></span>A<span class="s35">2</span><span class="s23"></span>B <span class="p">是不可满足的，先求出其 </span>Skolem <span class="p">范式中的子句集：</span></p><p class="s10" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">A<span class="s35">1</span>=<span class="s23"></span>x<span class="s23"></span>y(P(x)<span class="s23"></span>(<span class="s23"></span>D(y)<span class="s23"></span>L(x,y)))<span class="p">，</span></p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">Skolem <span class="p">范式为 </span><span class="s23"></span>y(P(a)<span class="s23"></span>(<span class="s23"></span>D(y)<span class="s23"></span>L(a,y)))</p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">A<span class="s35">2</span> = <span class="s23"></span>x<span class="s23"></span>y(<span class="s23"></span>P(x)<span class="s23"></span>Q(y)<span class="s23"></span>L(x,y))<span class="p">，</span>Skolem <span class="p">范式与前束范式相同</span></p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="s23"></span>B = <span class="s23"></span>x(D(x)<span class="s23"></span>Q(x)) <span class="p">，</span>Skolem <span class="p">范式为</span>D(b)<span class="s23"></span>Q(b)</p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">因此，</span>A<span class="s35">1</span><span class="s23"></span>A<span class="s35">2</span><span class="s23"></span>B <span class="p">公式的子句集为下述（</span>1<span class="p">）</span>-<span class="p">（</span>5<span class="p">）</span></p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">1</span>）<span class="s10">P(a)</span>；</p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>2<span class="p">）</span><span class="s23"></span>D(y)<span class="s23"></span>L(a,y)<span class="p">；</span></p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>3<span class="p">）</span><span class="s23"></span>P(x)<span class="s23"></span>Q(y)<span class="s23"></span>L(x,y)<span class="p">；</span></p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">4</span>）<span class="s10">D(b)</span>；</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">5</span>）<span class="s10">Q(b)</span>；</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">6</span>）<span class="s10">L(a,b)                              </span>由（<span class="s10">2</span>），（<span class="s10">4</span>）；</p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">（</span>7<span class="p">）</span><span class="s23"></span>Q(y)<span class="s23"></span>L(a,y)              <span class="p">由（</span>1<span class="p">），（</span>4<span class="p">）；</span></p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">8</span>）<span class="s23"></span><span class="s10">L(a,b)                            </span>由（<span class="s10">5</span>），（<span class="s10">7</span>）；</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">9</span>）<span class="s38"></span><span class="s10">                                    </span>由（<span class="s10">6</span>），（<span class="s10">8</span>）。</p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">2.2.4.3 <span class="s37">删除策略</span></p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">归结原理是比 <span class="s10">Gilmore </span>或 <span class="s10">Herbrand </span>方法更有效的判定一阶逻辑</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;"><span class="p">中公式的不可满足性的方法。但是，归结原理的效率，也由于在归结过程中产生大量的无用子句而受到影响。在子句集 </span>S <span class="p">上使用归结原理的最直接的一种方法是，计算 </span>S <span class="p">中所有子句对的归结式，并将这些归结式并入</span>S<span class="p">，再进一步计算所有子句对的归结式。重复此过程，直到空子句被导出。这个过程被称为水平浸透法。对前面例子中子句集 </span>S={P<span class="s23"></span>Q,<span class="s23"></span>P<span class="s23"></span>Q,P<span class="s23"></span>Q,<span class="s23"></span>P<span class="s23"></span>Q}<span class="p">使用水平浸透法，将生成非常多的对导出空子句无用的子句。</span></p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: left;">为了解决防止多余子句产生这个问题，提高归结推理效率，删除策略被引入。</p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;"><span class="p">称子句</span>C <span class="p">包含子句</span>D<span class="p">，当且仅当存在替换 </span>σ <span class="p">使得</span>C<span class="s20">σ</span><span class="s23"></span>D<span class="p">。</span>D <span class="p">称为被包含子句。例如，设</span>C=P(x), D=P(a)<span class="s23"></span>Q(a)<span class="p">，令</span>σ={a/x}<span class="p">，则</span>C<span class="s20">σ</span>=P(a)<span class="s23"></span>D<span class="p">，即 </span>C <span class="p">包含 </span>D<span class="p">。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">设 </span>S <span class="p">是子句集，下面的序列是从 </span>S <span class="p">出发推出子句 </span>C <span class="p">的演绎 </span>D<span class="p">： </span>C<span class="s35">1</span>,C<span class="s35">2</span>,...,C<span class="s35">k</span>(=C)<span class="p">。如果 </span>C<span class="s35">i</span> <span class="p">是重言式，或者 </span>C<span class="s35">i</span> <span class="p">被某个</span>C<span class="s35">j</span> <span class="p">包含（</span>j&lt;i<span class="p">），则将 </span>C<span class="s35">i</span> <span class="p">从这个演绎中删除，称对此演绎 </span>D <span class="p">实行了删除策略。删除策略是完备的，即，设 </span>S <span class="p">是不可满足子句集，如果在水平浸透法中使用删除策略，则最后仍可以推导出空子句。</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part43.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part45.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
