<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.2.6 等词推理</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part45.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part47.htm">下一个 &gt;</a></p><p class="s14" style="padding-left: 7pt;text-indent: 0pt;line-height: 22pt;text-align: left;"><a name="bookmark46">2.2.6 </a><span class="h4">等词推理</span></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">相等是数学中的重要且常用的概念之一，使用一阶逻辑来描述表达数学定理时经常需要使用相等这个二元谓词，下文中用<span class="s10">=</span>表示等词， <span class="s10">s=t</span>，实际上表示<span class="s10">=(s,t)</span>，用<span class="s10">≠</span>表示<span class="s23"></span><span class="s10">=</span>。对于包含等词的子句集 <span class="s10">S</span>，若<span class="s10">S</span>是不可满足的，使用归结原理不能找到从 <span class="s10">S </span>推出空子句的演绎。这是</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;">因为在应用归结原理的符号系统里，代表等词的<span class="s10">=</span>就是普通的二元谓词，在解释中可以被指定为任意的二元谓词，并不是一定会被指定为表示相等的谓词。在这种观点下，子句集 <span class="s10">S </span>有可能是可满足的，使用归结原理不能找到从 <span class="s10">S </span>推出空子句的演绎。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: justify;">为了对包含等词的问题进行推理，一种直接的方法是增加公理集合 <span class="s10">K</span>：</p><p class="s10" style="padding-left: 34pt;text-indent: 0pt;line-height: 18pt;text-align: left;">(1) x=x                                         <span class="p">（反身性）</span></p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(2) x≠y<span class="s23"></span>y=x                                 <span class="p">（对称性）</span></p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(3) x≠y<span class="s23"></span>y≠z<span class="s23"></span>x=z                         <span class="p">（传递性）</span></p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(4) x<span class="s35">j</span>≠x<span class="s35">0</span><span class="s23"></span>P(x<span class="s35">1</span>,...,x<span class="s35">j</span>,...,x<span class="s35">n</span>)<span class="s23"></span>P(x<span class="s35">1</span>,...,x<span class="s35">0</span>,...,x<span class="s35">n</span>)    j=1,2,...,n, P(x<span class="s35">1</span>,...,x<span class="s35">n</span>)</p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: justify;">是 <span class="s10">S </span>中任意的<span class="s10">n </span>元谓词符号 （等量代换）</p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">(5) x<span class="s35">j</span>≠x<span class="s35">0</span><span class="s23"></span>f(x<span class="s35">1</span>,...,x<span class="s35">j</span>,...,x<span class="s35">n</span>)=f(x<span class="s35">1</span>,...,x<span class="s35">0</span>,...,x<span class="s35">n</span>) j=1,2,...,n, f(x<span class="s35">1</span>,...,x<span class="s35">n</span>)<span class="p">是 </span>S <span class="p">中任意的</span>n <span class="p">元函数符号 （等量代换）</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">对于包含等词的子句集 </span>S<span class="p">，若 </span>S <span class="p">是不可满足的，则存在从 </span>S<span class="s23"></span>K<span class="p">推出空子句的演绎。这种方法的缺点是输入的子句集合增大，应用归结原理的过程中将生成更多的无用子句，效率降低。</span></p><p class="s20" style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: justify;"><a href="part327.htm#bookmark365" class="a">另外一种方法是设计专门的推理规则来处理等词的推理。下面介绍调解法</a>[86]<span class="s10"> </span><span class="p">，其本质上是等量替换规则的推广。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">以基情况为例，若子句 </span>C<span class="s35">1</span> <span class="p">和</span>C<span class="s35">2</span> <span class="p">分别为 </span>L[t]<span class="s23"></span>C<span class="s35">1</span>’<span class="p">和</span>t=s<span class="s23"></span>C<span class="s35">2</span>’<span class="p">，其中 </span>L[t]<span class="p">表示包含项 </span>t <span class="p">的文字，</span>C<span class="s35">1</span>’<span class="p">和 </span>C<span class="s35">2</span>’<span class="p">是子句，于是 </span>L[s]<span class="s23"></span>C<span class="s35">1</span>’<span class="s23"></span>C<span class="s35">2</span>’<span class="p">称为 </span>C<span class="s35">1</span><span class="p">和 </span>C<span class="s35">2</span> <span class="p">的调解式。</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">在一般子句上，例如</p><p class="s10" style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">C<span class="s35">1</span>: P(x)<span class="s23"></span>Q(b)</p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">C<span class="s35">2</span>: a=b<span class="s23"></span>R(b)</p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="p">尽管 </span>C<span class="s35">1</span> <span class="p">中不包含 </span>a<span class="p">，但替换</span>{a/x}<span class="p">作用在 </span>C<span class="s35">1</span> <span class="p">上得到 </span>C<span class="s35">1</span> <span class="p">的例包含</span></p><p class="s10" style="padding-top: 6pt;padding-left: 7pt;text-indent: 0pt;text-align: justify;">a<span class="p">，于是可以和 </span>C<span class="s35">2</span> <span class="p">进行调解，得到 </span>P(b)<span class="s23"></span>Q(b)<span class="s23"></span>R(b)<span class="p">。</span></p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">调解法提出以后，和归结方法一样，为提高其效率，很多改进方</p><p class="s10" style="padding-top: 8pt;padding-left: 34pt;text-indent: -28pt;line-height: 139%;text-align: left;"><span class="p">法被提出来。例如：支撑集调解法，线性调解法，</span>P <a href="part327.htm#bookmark363" class="a">超调解</a><span class="s20">[84]</span> <span class="p">等。设 </span>P <span class="p">是子句 </span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">中谓词符号的一个次序，</span>C<span class="s35">1</span> <span class="p">和 </span>C<span class="s35">2</span> <span class="p">的一个调</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span class="p">解式称为</span>P <span class="p">超调解式，当且仅当满足条件：</span>C<span class="s35">1</span> <span class="p">和</span>C<span class="s35">2</span> <span class="p">是正子句；</span>C<span class="s35">1</span> <span class="p">和</span></p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">C<span class="s35">2</span> <span class="p">中的调解文字分别是 </span>C<span class="s35">1</span> <span class="p">和</span>C<span class="s35">2</span> <span class="p">中最大谓词符号。</span></p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">从 </span>S <span class="p">出发使用归结和调解的 </span>P <span class="p">超演绎是一个子句序列，其中的每个子句或者来自</span>S<span class="p">，或者是一个 </span>P <span class="p">超归结式，或者是一个 </span>P <span class="p">超调解式。对于含等词的不可满足子句集 </span>S<span class="p">，存在从 </span>S<span class="s23"></span>{x=x}<span class="s23"></span>F <span class="p">推出空子句的 </span>P <span class="p">超演绎，其中 </span>F <span class="p">是关于 </span>S <span class="p">中出现的全部函数符号的反身公理集。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">1973 <span class="p">年，</span>Chang, C. L.<span class="p">和 </span>Lee<span class="p">，</span>R. C. T.<span class="p">出版了人工智能领域颇具影响力的专著《</span>Symbolic Logic and Mechanical Theorem Proving<a href="part327.htm#bookmark363" class="a">》</a><span class="s20">[84]</span> <span class="p">。 </span>1990 <span class="p">年，吉林大学刘叙华团队发现该专著中关于输入调解和单元调解等价性的猜测是错误的，并发现 </span>Chang <span class="p">和 </span>Lee <span class="p">在定义调解和使用调解时，存在着某种含混，从而导致一批引理和定理都可能是错误的，甚至线性调解的完备性都可能是错误的。为此，引入了对称调解的概念，使得 </span>Chang <span class="p">和 </span>Lee <a href="part327.htm#bookmark380" class="a">著作中的所有含混之处都变得明确起来，并进一步指出了调解和对称调解各自的优缺点</a><span class="s20">[102]</span> <span class="p">。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">后来，从调解法又发展出 </span>superposition <a href="part327.htm#bookmark366" class="a">方法，这是当前主流的等词推理方法</a><span class="s20">[87]</span> <span class="p">。引入项的次序，要求等量替换时只能对排序在前的项应用，进而减少新生成的文字。例如，对于等词 </span>s[l]=t <span class="p">和</span>l=r<span class="p">，只有当 </span>s&gt;t, l&gt;r <span class="p">时，才能用 </span>r <span class="p">替换 </span>l <span class="p">得出 </span>s[r]=t<span class="p">，其中 </span>s[l]<span class="p">表示包含项 </span>l <span class="p">的项。</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part45.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part47.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
