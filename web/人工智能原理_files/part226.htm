<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>10.9 压缩/解码原理</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part225.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part227.htm">下一个 &gt;</a></p><p class="s8" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><a name="bookmark213">10.9 </a><span class="s9">压缩</span>/<span class="s9">解码原理</span></p><p style="padding-top: 2pt;padding-left: 35pt;text-indent: 0pt;text-align: left;"><span class="h4">定理 </span><span class="s14">10.2</span>（压缩<span class="s10">/</span>解码原理）对任意不可约非负矩阵 <span class="s11">𝐴</span>：</p><p style="padding-top: 3pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">1</span>）对 <span class="s11">𝐴 </span>的任何一个编码树 <span class="s11">𝑇</span>，有</p><p class="s11" style="padding-top: 7pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">𝒞<span class="s19">𝑇</span>(𝐴) = ℋ<span class="s19">1</span>(𝐴) − ℋ<span class="s19">𝑇</span>(𝐴) = 𝒟<span class="s19">𝑇</span>(𝐴).</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">2</span>）对 <span class="s11">𝐴</span>，有</p><p class="s11" style="padding-top: 7pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">𝒞(𝐴) = ℋ<span class="s19">1</span>(𝐴) − ℋ(𝐴) = 𝒟(𝐴).</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">3</span>）对任何 <span class="s11">𝑘 ≥ 2</span>，</p><p class="s11" style="padding-top: 7pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">𝒞<span class="s19">𝑘</span>(𝐴) = ℋ<span class="s19">1</span>(𝐴) − ℋ<span class="s19">𝑘</span>(𝐴) = 𝒟<span class="s19">𝑘</span>(𝐴).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">4</span>）对 <span class="s11">𝐴 </span>的任何编码树类型 <span class="s11">𝒯</span></p><p class="s11" style="padding-top: 7pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">𝒞 <span class="s19">𝒯</span>(𝐴) = ℋ<span class="s19">1</span>(𝐴) − ℋ<span class="s19">𝒯</span>(𝐴) = 𝒟<span class="s19">𝒯</span>(𝐴).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 14pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">压缩<span class="s10">/</span>解码信息原理揭示了，对任何不可约非负矩阵 <span class="s11">𝐴 </span>及 <span class="s11">𝐴 </span>的编码树 <span class="s11">𝑇</span>，<span class="s11">𝑇 </span>从 <span class="s11">𝐴 </span>中的解码信息 <span class="s11">𝒟</span><span class="s19">𝑇</span><span class="s11">(𝐴) </span>和 <span class="s11">𝑇 </span>对 <span class="s11">𝐴 </span>的压缩信息一样，即</p><p style="text-indent: 0pt;text-align: left;"><span><img width="23" height="1" alt="image" src="Image_077.png"/></span></p><p class="s11" style="padding-left: 3pt;text-indent: 0pt;text-align: center;">𝒟<span class="s19">𝑇</span>(𝐴) = 𝒞<span class="s19">𝑇</span>(𝐴).</p><p style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">因此，对任何<span class="s11">𝛼 ∈ 𝑇</span>，<span class="s11">−𝑞</span><span class="s41">𝛼</span></p><p class="s11" style="padding-top: 7pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">log</p><p class="s16" style="padding-top: 4pt;text-indent: 10pt;line-height: 89%;text-align: left;">𝑉<span class="s50">𝛼</span><span class="s68"> </span><span class="s129">2 </span>𝑉<span class="s50">𝛼</span><span class="s61">−</span></p><p style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">是模块 <span class="s11">𝛼 </span>的压缩信息，它也</p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">可以理解为模块 <span class="s11">𝛼 </span>消除的 <span class="s11">𝐴 </span>中的不确定性。直观地说：</p><p style="padding-top: 13pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">1</span>）压缩信息就是解码信息；</p><p style="padding-top: 13pt;padding-left: 7pt;text-indent: 27pt;line-height: 174%;text-align: left;">（<span class="s10">2</span>）压缩了多少信息也就是消除了多少不确定性，等价地，消除的不确定性就是压缩的信息；</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 174%;text-align: left;">（<span class="s10">3</span>）由于压缩信息是显示地分布在编码树 <span class="s11">𝑇 </span>上的，所以解码信息也是显示地分布在编码树 <span class="s11">𝑇 </span>上的；</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 174%;text-align: left;">（<span class="s10">4</span>）编码树 <span class="s11">𝑇 </span>不仅有解码功能，即消除嵌入在 <span class="s11">𝐴 </span>中的不确定性，而且 <span class="s11">𝑇 </span>消除的嵌入在 <span class="s11">𝐴 </span>中的不确定性显示地分布在编码树 <span class="s11">𝑇</span>的节点上；</p><p class="s11" style="padding-left: 7pt;text-indent: 27pt;line-height: 174%;text-align: left;"><span class="p">（</span><span class="s10">5</span><span class="p">）结构熵 </span>ℋ<span class="s19">𝑇</span>(𝐴) <span class="p">显示地分布在编码树的节点上，同样地，解码信息</span>𝒟<span class="s19">𝑇</span>(𝐴) <span class="p">也显示地分布在编码树 </span>𝑇 <span class="p">的节点上。</span></p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 174%;text-align: left;">编码树 <span class="s11">𝑇 </span>的以上性质为信息演算，即基于编码树的推理理论，奠定了基础。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part225.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part227.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
