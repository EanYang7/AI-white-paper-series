<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.2.5 归结原理的改进策略</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part44.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part46.htm">下一个 &gt;</a></p><p class="s14" style="padding-left: 7pt;text-indent: 0pt;line-height: 22pt;text-align: left;"><a name="bookmark45">2.2.5 </a><span class="h4">归结原理的改进策略</span></p><p class="s10" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">2.2.5.1 <span class="s37">语义归结</span></p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">子句集</span>S <span class="p">的子集 </span>T <span class="p">称为 </span>S <span class="p">的支撑集，如果 </span>S<span class="p">－</span>T <span class="p">是可满足的。一个支撑集归结是一个不同时属于 </span>S<span class="p">－</span>T <span class="p">的两个子句的归结。支撑集归结式 </span>L. Wos, J.A. Robinson <span class="p">和 </span>D.F.Carson <span class="p">于 </span>1965 <a href="part327.htm#bookmark359" class="a">年提出</a><span class="s20">[80]</span> <span class="p">。这种策略的思想比较直观：在一阶逻辑中证明 </span>A<span class="s35">1</span>,...,A<span class="s35">n</span> <span class="p">共同蕴涵 </span>B<span class="p">，即证明 </span>(A<span class="s35">1</span><span class="s23"></span>...<span class="s23"></span>A<span class="s35">n</span>)<span class="s23"></span>B <span class="p">为恒真公式，归结方法是去证明 </span>A<span class="s35">1</span><span class="s23"></span>...<span class="s23"></span>A<span class="s35">n</span><span class="s23"></span>B <span class="p">是不可满足的。通常，前提集合</span>{A<span class="s35">1</span>,...,A<span class="s35">n</span>}<span class="p">是可满足的。因此，要找出矛盾</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 140%;text-align: left;"><span class="p">（即空子句），避免在</span>{A<span class="s35">1</span>,...,A<span class="s35">n</span>}<span class="p">中的子句进行归结是明智的。这就是支撑集归结的来源。支撑集归结是完备的。</span></p><p class="s10" style="padding-top: 8pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;"><a href="part327.htm#bookmark360" class="a">与支撑集归结的思想相似，语义归结</a><span class="s20">[81]</span> <span class="p">的核心思想是通过一个解释 </span>I<span class="p">，在解释 </span>I <span class="p">下输入子句集 </span>S <span class="p">一定会被划分为非空的两个子集：被满足的子句子集 </span>S<span class="s35">1</span> <span class="p">和被弄假的子句子集 </span>S<span class="s35">2</span><span class="p">。语义归结要求进行归结的两个子句只能来源于不同的子集。语义归结中也对谓词符号进行排序，在应用归结方法时要求只能应用在子句中最大的谓词符号上。当解释</span>I <span class="p">中只有正文字（或者负文字）时，语义归结又被称为正超归结（或者负超归结）。语义归结和超归结都是完备的。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">2.2.5.2 Horn <span class="s37">集上的归结原理</span></p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">单元归结：归结的两个子句中有一个单文字子句。输入归结：归结的两个子句中有一个子句来自最初给定的子句集合 <span class="s10">S</span>。若一个演绎中的每个归结步骤都是单元（输入）归结，则称之为单元（输入）演绎。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">存在从子句集<span class="s10">S </span>推出空子句的单元演绎当且仅当存在从子句集<span class="s10">S</span>推出空子句的输入演绎。单元归结和输入归结这样好的推理方法，却是不完备的，例如前面的例 <span class="s10">1</span>。然而，对于一类特殊子句集，<span class="s10">Horn </span>集是完备的。<span class="s10">Horn </span>集虽然特殊，却用途广泛。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: justify;">如果一个子句中最多有一个正文字，则称此子句为 <span class="s10">Horn </span>子句；由 <span class="s10">Horn </span>子句构成的子句集，称为 <span class="s10">Horn </span>集。如下一个 <span class="s10">Horn </span>集</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: left;">{<span class="s23"></span>A<span class="s35">1</span><span class="s23"></span>A<span class="s35">2</span><span class="s23"></span>A<span class="s35">3</span><span class="s23"></span>B<span class="s35">1</span>,<span class="s23"></span>A<span class="s35">4</span><span class="s23"></span>A<span class="s35">5</span><span class="s23"></span>B<span class="s35">2</span>,P<span class="s23"></span>Q,A<span class="s35">1</span>,A<span class="s35">4</span>,P}<span class="p">恰好描写了如下一组知识：</span></p><p class="s10" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">(1) A1</p><p class="s10" style="padding-top: 8pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(2) A4</p><p class="s10" style="padding-top: 8pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(3) P</p><p class="s10" style="padding-top: 8pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(4) A1<span class="s23"></span>A2<span class="s23"></span>A3<span class="s23"></span>B1</p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(5) A4<span class="s23"></span>A5<span class="s23"></span>B2</p><p class="s10" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">(6) P<span class="s23"></span>Q</p><p style="padding-top: 8pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">其中前三条公式描述了事实，后三条公式描述了规则。<span class="s10">Horn </span>集描</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: left;">述的知识（事实与规则）恰好是知识工程中经常使用的知识表示方法。因此，针对 <span class="s10">Horn </span>集上归结方法有许多研究工作与改进成果。例如，前述提到的单元归结与输入归结是不完备的。即对于普通的不可满足子句集，仅使用单元演绎或者输入演绎最后未必能推导出空子句。但是单元归结与输入归结对 <span class="s10">Horn </span>集是完备的。设 <span class="s10">S </span>是不可满足的 <span class="s10">Horn</span>集，于是存在从 <span class="s10">S </span>推出空子句的输入演绎和单元演绎。</p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">2.2.5.3 <span class="s37">广义归结</span></p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">应用归结原理证明谓词公式 <span class="s10">G </span>不可满足时，需要先得到 <span class="s10">G </span>的 <span class="s10">Skolem </span>范式，这种范式的母式是合取范式，首标中只有全称量词。因此，归结方法的输入是来自合取范式中的子句构成的集合，子句中出现的变量均是受全称量词限制。求 <span class="s10">Skolem </span>范式的过程繁琐费时，研究者们试着避开这一环节。</p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">1979 <span class="p">年王湘浩、刘叙华提出了广义归结方法，</span>1982 <a href="part327.htm#bookmark379" class="a">年发表于《计算机学报》</a><span class="s20">[101]</span> <span class="p">；同年， </span>N. V. Murray <span class="p">在国际权威期刊 </span><i>Artificial Intelligence</i><span class="s37">(</span><i>AIJ</i><span class="s37">)</span><span class="p">发表论文，提出一种非子句形式的 </span>NC <a href="part327.htm#bookmark364" class="a">归结方法</a><span class="s20">[85]</span> <span class="p">。 </span>1992 <span class="p">年，刘叙华和孙吉贵研究、比较了广义归结和 </span>NC <span class="p">归结，证明了：</span>NC <span class="p">归结对于锁归结、有序归结、语义归结和线性半锁归结都是不完备的，并指出 </span>Murray <a href="part327.htm#bookmark380" class="a">论文中的错误。刘叙华在其专著</a><span class="s20">[102]</span> <span class="p">中指出：不论是由复杂文字组成的子句的归结</span><span class="s37">(</span>T. Bollinger <span class="p">在 </span>IJCAI-91 <a href="part327.htm#bookmark381" class="a">上发表的论文</a><span class="s20">[103]</span> <span class="s37">)</span><span class="p">，还是 </span>NC(Non Clausal)<span class="p">归结</span><span class="s37">(</span>1982 <span class="p">年，</span>Murray <span class="p">在 </span><i>AI</i><a href="part327.htm#bookmark364" class="a">上发表的论文</a><span class="s20">[85]</span> <span class="s37">)</span><span class="p">，都是在广义归结中加上某种简单限制，这些限制既带来一些好处，同时也带来一些坏处。</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part44.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part46.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
