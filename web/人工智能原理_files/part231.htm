<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>10.13 基于结构熵的推理演算</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part230.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part232.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 11pt;padding-left: 7pt;text-indent: 0pt;text-align: left;"><a name="bookmark217">10.13 </a><span class="s9">基于结构熵的推理演算</span></p><p style="padding-top: 6pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">给定信息系统 <span class="s11">𝐴</span>，即 <span class="s11">𝐴 </span>是一个不可约非负矩阵。假设 <span class="s11">𝑇 </span>是按结构熵极小化原理求解的一个 <span class="s11">𝐴 </span>的编码树。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 35pt;text-indent: 0pt;line-height: 25pt;text-align: left;">定义 <span class="s14">10.19</span><span class="p">（模块的结构熵）</span></h4><p style="padding-left: 34pt;text-indent: 0pt;line-height: 25pt;text-align: left;">（<span class="s10">1</span>）对于 <span class="s11">𝛼 ∈ 𝑇</span>，定义<span class="h4">模块 </span><span class="s11">𝜶 </span><span class="h4">的结构熵</span>为：</p><p class="s11" style="padding-top: 12pt;padding-left: 140pt;text-indent: 0pt;text-align: left;">ℋ<span class="s19">𝑇</span>(𝐴; 𝛼) = −𝑝<span class="s41">𝛼</span></p><p class="s11" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;line-height: 23pt;text-align: left;">log <span class="s84">𝑉</span><span class="s131">𝛼</span><span class="s71"> </span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="28" height="1" alt="image" src="Image_080.png"/></span></p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;line-height: 15pt;text-align: left;">𝑉<span class="s15">𝛼</span><span class="s127">−</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;line-height: 25pt;text-align: left;">（<span class="s10">2</span>）对于 <span class="s11">𝛼 ∈ 𝑇</span>，定义<span class="h4">层谱抽象 </span><span class="s11">[𝜶, 𝝀) </span><span class="h4">的结构熵</span>为：</p><p class="s11" style="padding-top: 8pt;padding-left: 108pt;text-indent: 0pt;text-align: left;">ℋ<span class="s19">𝑇</span>(𝐴; [𝛼, 𝜆)) = − ∑ 𝑝<span class="s17">𝛽</span></p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;line-height: 13pt;text-align: left;">𝑉<span class="s15">𝛽</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="27" height="1" alt="image" src="Image_081.png"/></span></p><p class="s11" style="padding-left: 1pt;text-indent: 0pt;line-height: 9pt;text-align: left;">log    .</p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;line-height: 11pt;text-align: left;">𝑉<span class="s15">𝛽</span><span class="s127">−</span></p><p class="s16" style="padding-left: 36pt;text-indent: 0pt;line-height: 10pt;text-align: center;">𝜆⊂𝛽⊆𝛼</p><p style="padding-top: 3pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">（<span class="s10">3</span>）给定 <span class="s11">𝑇 </span>的子集合 <span class="s11">𝑀 ⊂ 𝑇</span>，定义<span class="h4">模块 </span><span class="s11">𝑴 </span><span class="h4">的结构熵</span>为：</p><p class="s11" style="padding-top: 12pt;padding-left: 126pt;text-indent: 0pt;text-align: left;">ℋ<span class="s19">𝑇</span>(𝐴; 𝑀) = − ∑ 𝑝<span class="s17">𝛼</span></p><p class="s16" style="padding-top: 3pt;padding-left: 217pt;text-indent: 0pt;line-height: 11pt;text-align: left;">𝛼∈𝑀</p><p class="s16" style="padding-left: 218pt;text-indent: 0pt;line-height: 11pt;text-align: left;">𝛼≠𝜆</p><p class="s11" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;line-height: 23pt;text-align: left;">log <span class="s84">𝑉</span><span class="s131">𝛼</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="28" height="1" alt="image" src="Image_082.png"/></span></p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;line-height: 15pt;text-align: left;">𝑉<span class="s15">𝛼</span><span class="s127">−</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 13pt;text-indent: 0pt;line-height: 18pt;text-align: right;">= − ∫ 𝑝<span class="s15">𝛼</span></p><p class="s16" style="text-indent: 0pt;line-height: 11pt;text-align: right;">𝑀</p><p class="s11" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;line-height: 23pt;text-align: left;">log <span class="s84">𝑉</span><span class="s131">𝛼</span><span class="s71">  </span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="28" height="1" alt="image" src="Image_083.png"/></span></p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;line-height: 15pt;text-align: left;">𝑉<span class="s15">𝛼</span><span class="s127">−</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 35pt;text-indent: 0pt;line-height: 24pt;text-align: left;">定义 <span class="s14">10.20</span><span class="p">（条件结构熵）给定 </span><span class="s11">𝑀, 𝑁 ⊂ 𝑇</span><span class="p">，定义在</span>条件 <span class="s11">𝑴 </span>下 <span class="s11">𝑵</span></h4><h4 style="padding-left: 7pt;text-indent: 0pt;line-height: 25pt;text-align: left;">的结构熵<span class="p">为：</span></h4><p class="s11" style="padding-top: 11pt;padding-left: 112pt;text-indent: 0pt;text-align: left;">ℋ<span class="s19">𝑇</span>(𝐴; 𝑁|𝑀) = − ∑ 𝑝<span class="s17">𝛼</span></p><p class="s11" style="padding-top: 1pt;padding-left: 1pt;text-indent: 0pt;line-height: 23pt;text-align: left;">log <span class="s84">𝑉</span><span class="s131">𝛼</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="28" height="1" alt="image" src="Image_084.png"/></span></p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;line-height: 10pt;text-align: left;">𝑉<span class="s15">𝛼</span><span class="s127">−</span></p><p class="s16" style="padding-left: 224pt;text-indent: 0pt;line-height: 10pt;text-align: center;">𝛼∈𝑁\𝑀</p><p class="s16" style="padding-left: 224pt;text-indent: 0pt;text-align: center;">𝛼≠𝜆</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;line-height: 18pt;text-align: right;">= − ∫     𝑝<span class="s15">𝛼</span></p><p class="s16" style="padding-left: 224pt;text-indent: 0pt;line-height: 11pt;text-align: center;">𝑁\𝑀</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 1pt;text-indent: 0pt;line-height: 23pt;text-align: left;">log <span class="s84">𝑉</span><span class="s131">𝛼</span><span class="s71">  </span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="28" height="1" alt="image" src="Image_085.png"/></span></p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;line-height: 15pt;text-align: left;">𝑉<span class="s15">𝛼</span><span class="s127">−</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 7pt;padding-left: 7pt;text-indent: 28pt;line-height: 113%;text-align: left;"><span class="h4">定义 </span><span class="s14">10.21</span><span class="p">（推理的结构熵极小原理）给定 </span>𝑇 <span class="p">的子集合 </span>𝑀 ⊂ 𝑇<span class="p">，求 </span>𝑁 = [𝛾, 𝜆)<span class="p">，对某叶子节点 </span>𝛾 ∈ 𝑇<span class="p">，使得 </span>ℋ<span class="s19">𝑇</span>(𝐴; 𝑁|𝑀)<span class="p">极小，即：</span></p><p class="s11" style="padding-top: 4pt;padding-left: 129pt;text-indent: 0pt;text-align: left;">𝑁<span class="s19">∗</span> = 𝑎𝑟𝑔𝑚𝑖𝑛{ℋ<span class="s19">𝑇</span>(𝐴; 𝑁|𝑀)},</p><p class="s11" style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">𝑁 <span class="p">是从 </span>𝜆 <span class="p">到某个叶子的路径上的所有节点构成的集合。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 12pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">结构熵极小化原理使得我们能推断在已知 <span class="s11">𝑀 </span>中模块的条件下找到最有可能的一个个体，即不确定性最小的个体。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: left;">类似地我们可以提出在已知一些模块的条件下推断出最有可能的若干个个体。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;"><span class="h4">定义 </span><span class="s14">10.22</span>（推理的结构熵极大化原理）给定 <span class="s11">𝑀 ⊂ 𝑇</span>，求解 <span class="s11">𝑁 ≠</span></p><p class="s11" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">𝑀 <span class="p">使得</span>𝑁 = [𝛾, 𝜆)<span class="p">，对某叶子节点 </span>𝛾 ∈ 𝑇<span class="p">，使得 </span>ℋ<span class="s19">𝑇</span>(𝐴; 𝑁|𝑀)<span class="p">最大。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 11pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">推理的结构熵极大化原理允许我们在已知一些模块的条件下推断出不确定性最大，也就是最不稳定的个体。同样原理，可以求出多个不确定性最大的个体。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: left;">在给定条件下，熵最小，即最有可能；熵最大，即最不可能，或最不稳定的对象，这两种对象在不同的应用场景中都是有意义的。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;">基于结构熵的推理是在编码树上的推理，编码树是优化的层谱抽象结构，因此，基于编码树的推理是跨越抽象层次的推理和同一抽象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: left;">层次推理的结合，从而是直觉推理和逻辑推理相结合的推理。这就数学地实现了直觉推理和逻辑推理的结合，建立了推理的数学理论。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part230.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part232.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
