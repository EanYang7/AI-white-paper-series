<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.2.2 Herbrand 定理</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part41.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part43.htm">下一个 &gt;</a></p><p class="s14" style="padding-left: 7pt;text-indent: 0pt;line-height: 22pt;text-align: left;"><a name="bookmark42">2.2.2 Herbrand </a><span class="h4">定理</span></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">在离散数学中证明过 <span class="s10">Skolem </span>范式的性质：设谓词逻辑公式 <span class="s10">G </span>的 <span class="s10">Skolem </span>范式为 <span class="s10">S</span>，则 <span class="s10">G </span>的不可满足性与 <span class="s10">S </span>的不可满足性等价。因此，若想证明谓词逻辑公式 <span class="s10">G </span>是不可满足的，可以通过证明 <span class="s10">S </span>的不可满足性来实现。相比于公式 <span class="s10">G </span>可以具有任意形式，<span class="s10">S </span>是只包含全称量词的前束范式，并且母式为合取范式（若干个子句的合取）。因此，<span class="s10">S </span>可以看成是一个子句集合，该集合中出现的量词均是被全称量词作用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: left;">这就是下面经常谈论子句集的原因。项、文字、子句等若不含变量，则相应地称为基项、基文字和基子句。</p><p style="padding-left: 34pt;text-indent: 0pt;text-align: justify;">首先介绍子句集 <span class="s10">S </span>的 <span class="s10">Herbrand </span>域。</p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">设 </span>H<span class="s35">0</span> <span class="p">是出现于子句集 </span>S <span class="p">的常量符号集合，若 </span>S <span class="p">中无常量符号出现，则</span>H<span class="s35">0</span> <span class="p">由一个常量符号</span>a <span class="p">组成。对于</span>i=1,2,..., <span class="p">在</span>H<span class="s35">i-1</span> <span class="p">中加入</span>f<span class="s35">n</span>(t<span class="s35">1</span>,...,t<span class="s35">n</span>)<span class="p">得到的集合 </span>H<span class="s35">i</span> <span class="p">称为 </span>S <span class="p">的 </span>i <span class="p">级常量集，其中 </span>f<span class="s20">n</span> <span class="p">是出现在 </span>S <span class="p">中的所有 </span>n<span class="p">元函数符号，项 </span>t<span class="s35">1</span>,...,t<span class="s35">n</span> <span class="p">取自 </span>H<span class="s35">i-1</span><span class="p">。</span>H<span class="s36">∞</span><span class="p">称为 </span>S <span class="p">的 </span>Herbrand <span class="p">域。</span></p><p class="s10" style="padding-left: 34pt;text-indent: 0pt;line-height: 145%;text-align: left;"><span class="p">例 </span>1<span class="p">： </span>S = {P(f(x), a, g(y,z), b)}<span class="p">，于是， </span>H<span class="s35">0</span> = {a, b}</p><p class="s10" style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">H<span class="s35">1</span> = {a, b, f(a), f(b), g(a, a), g(a, b), g(b, a), g(b,b)}</p><p class="s10" style="padding-top: 8pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">H<span class="s35">2</span> = {a, b, f(a), f(b), g(a,a), g(a,b), g(b,a), g(b,b), f(f(a)), f(f(b)),</p><p class="s10" style="padding-top: 8pt;padding-left: 7pt;text-indent: 0pt;line-height: 155%;text-align: left;">f(g(a,a)), f(g(a,b)), f(g(b,a)), f(g(b,b)), g(a,f(a)), g(a,f(b)), g(a,g(a,a)), g(a,g(a,b)), ...}</p><p style="padding-left: 34pt;text-indent: 0pt;line-height: 17pt;text-align: justify;">只要子句集 <span class="s10">S </span>中包含函数符号，则 <span class="s10">S </span>的 <span class="s10">Herbrand </span>域是无限集。</p><p style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;">对于子句集 <span class="s10">S </span>中子句 <span class="s10">C</span>，使用 <span class="s10">S </span>的 <span class="s10">Herbrand </span>域中元素代替 <span class="s10">C </span>中变量得到的基子句构成的集合称为 <span class="s10">C </span>的基例集。</p><p style="padding-left: 34pt;text-indent: 0pt;text-align: justify;">定理 <span class="s10">1</span>（<span class="s10">Herbrand </span>定理）子句集 <span class="s10">S </span>是不可满足的，当且仅当存在</p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 0pt;text-align: justify;">S <span class="p">的一个有限不可满足的 </span>S <span class="p">的基例集 </span>S’<span class="p">。</span></p><p class="s10" style="padding-top: 7pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">Herbrand <span class="p">定理指出了一种证明子句集</span>S <span class="p">的不可满足性的方法：如果存在一个机械程序，它可以分别用 </span>H<span class="s35">1</span>,H<span class="s35">2</span>,...<span class="p">中的元素生成 </span>S <span class="p">中子句的基例集 </span>S<span class="s35">1</span>’,....,S<span class="s35">n</span>’<span class="p">，并依次检查 </span>S<span class="s35">1</span>’,....,S<span class="s35">n</span>’,...<span class="p">的不可满足性，那么根据 </span>Herbrand <span class="p">定理，如果 </span>S <span class="p">是不可满足的，则这个程序一定可以找到一个有限数</span>N<span class="p">，使</span>S<span class="s35">N</span>’<span class="p">是不可满足的。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">因为每个 </span>S<span class="s35">i</span>’<span class="p">可以视为该集合中全部基子句的合取，因此可以使用命题逻辑中的任意方法检查 </span>S<span class="s35">i</span>’<span class="p">的不可满足性。</span>Gilmore <span class="p">是实现这个想法的第一人，他将 </span>S<span class="s35">i</span>’<span class="p">化为析取范式，如果其中任意一个短语包含一个互补对（文字与该文字的否定），则可以从析取范式中删除该短</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;"><span class="p">语。最后，如果某个 </span>S<span class="s35">i</span>’<span class="p">是空的，则 </span>S<span class="s35">i</span>’<span class="p">是不可满足的。</span>Gilmore <span class="p">方法需要求析取范式，因此面临组合爆炸的情况，为了克服这个缺点，</span>Davis<span class="p">和 </span>Putnam <span class="p">提出改进方法，即后来的 </span>DPLL <a href="part327.htm#bookmark356" class="a">过程</a><span class="s20">[77]</span> <span class="p">。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">即使采用</span>DPLL <span class="p">来判定命题公式的不可满足性，</span>Herbrand <span class="p">定理的主要障碍仍然是它要求生成关于子句集 </span>S <span class="p">的基例集 </span>S<span class="s35">1</span>’,S<span class="s35">2</span>’ ,<span class="p">，在多</span></p><p class="s10" style="padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;"><span class="p">数情况下，这些集合的元素个数是以指数方式增加的。非常有可能发生：子句集 </span>S <span class="p">的最小的不可满足基例集 </span>S<span class="s35">k</span>’<span class="p">的元素数远超计算机的存储能力，更别提来判定 </span>S<span class="s35">k</span>’<span class="p">的不可满足性了。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">为了避免上述情况，</span>J.A.Robinson <span class="p">于 </span>1965 <a href="part327.htm#bookmark357" class="a">年文章中提出归结原理</a><span class="s20">[78]</span> <span class="p">，可以直接判定任意子句集 </span>S<span class="p">（不一定是基子句集）的不可满足性，其的核心思想是合一算法，通过合一算法来主动生成能证明 </span>S<span class="p">不可满足性的实例。</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part41.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part43.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
