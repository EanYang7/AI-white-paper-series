<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.3.5 不可分物品的公平分配</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part132.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part134.htm">下一个 &gt;</a></p><p class="s14" style="padding-left: 7pt;text-indent: 0pt;line-height: 22pt;text-align: left;"><a name="bookmark138">7.3.5 </a><span class="h4">不可分物品的公平分配</span></p><p class="s20" style="padding-top: 3pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: left;"><a href="part333.htm#bookmark671" class="a">由于在生活中并不是所有物品都是可分的，例如教师分配课程，云计算资源的分配。不可分割的物品有很大的应用价值。因此最近的研究对不可分割物品十分关注</a>[18]<span class="s10"> </span><span class="p">。在本节中，我们将介绍不可分物品的公平分配方法。</span></p><p class="s14" style="padding-left: 35pt;text-indent: 0pt;line-height: 22pt;text-align: left;">“<span class="h4">分和选</span>”<span class="h4">（</span>Divide and Choose<span class="h4">）</span><span class="p">与之前可分割的物品的公平分配</span></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;">类似，在只有两个参与者时，“分和选”方法十分直观并且有效。其流程是让一位参与者将所有不可分割的物品分成两捆，让另一位玩家去选择自己喜欢的一捆，剩下的一捆给第一个参与者。由于第一个参与者获得的是剩下的一捆，因此他在分成两捆时的最优策略是：</p><p class="s11" style="padding-left: 82pt;text-indent: 0pt;line-height: 12pt;text-align: left;">(𝑋<span class="s17">1</span>, 𝑋<span class="s17">2</span>) ∈ 𝑎𝑟𝑔         𝑚𝑎𝑥</p><p class="s16" style="text-indent: 0pt;line-height: 12pt;text-align: right;">(𝑆<span class="s50">1</span>,𝑆<span class="s50">2</span>)∈𝒜<span class="s50">2</span>(𝑀)</p><p class="s11" style="text-indent: 0pt;line-height: 17pt;text-align: left;">𝑚𝑖𝑛{𝑉<span class="s15">1</span>(𝑆<span class="s15">1</span>), 𝑉<span class="s15">2</span>(𝑆<span class="s15">2</span>)}.</p><p class="s11" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: left;"><span class="s10">Plaut </span><span class="p">和 </span><a href="part333.htm#bookmark672" class="s5">Roughgarden</a><span class="s20">[19]</span><span class="s10"> </span><span class="p">证明，如果我们通过最大化</span>(𝑋<span class="s15">1</span>, 𝑋<span class="s15">2</span>)<span class="p">中较</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;"><span class="p">小的捆的大小来打破平局，那么</span>(<i>X</i><i>1</i><i>, X</i><i>2</i>)<span class="p">对第一个参与者总是 </span>MMS <span class="p">和 </span>EFX <span class="p">的。而对于第二个参与者来说，他选择的是他更喜欢的一捆，因此对他来说这个分配是无嫉妒的。因此“分和选”方法是 </span>EFX <span class="p">和 </span>MMS<span class="p">分配。</span></p><p class="s10" style="padding-left: 7pt;text-indent: 28pt;line-height: 139%;text-align: justify;"><b>Sequential Allocation  and Round-Robin </b><span class="p">同样适用于不可分割物品的平均分配的是顺序拣选分配算法</span><a href="part333.htm#bookmark673" class="s5">[Brams and Taylor]</a><a href="part333.htm#bookmark673" class="s33">[20</a><span class="s20">]</span>   <span class="p">。</span>Bouveret<span class="p">和 </span><a href="part333.htm#bookmark674" class="s5">Lang</a><a href="part333.htm#bookmark674" class="s33">[21</a><span class="s20">]</span>   <span class="p">对其进行了深入的研究和讨论。在这些方法中，参与者有一系列的回合来挑选他们最喜欢的、未被他人挑选的物品。比较流行的顺序拣选分配是 </span>Round-Robin<span class="p">，其中挑选序列重复模式为</span><span class="s11">1, ⋯ , 𝑛</span><span class="p">。循环算法对不可分割的物品分配都是 </span>EF1<span class="p">（但不一定是 </span>EFX<span class="p">），但对混合分配却不是。为此，</span>Aziz  <a href="part333.htm#bookmark662" class="a">等人</a><a href="part333.htm#bookmark662" class="s33">[9</a><span class="s20">]</span>   <span class="p">提出了双循环方法，该方法可以给出针对混合分配的 </span>EF1 <span class="p">分配。</span>Amanatidis <a href="part333.htm#bookmark675" class="a">等人</a><a href="part333.htm#bookmark675" class="s33">[22</a><span class="s20">]</span>   <span class="p">和 </span>Aziz <span class="p">等人分别设计了更多的挑选序列，以达到近似 </span>MMS <span class="p">公平性。</span></p><p class="s14" style="padding-left: 7pt;text-indent: 28pt;line-height: 139%;text-align: justify;">Adjusted-Winner <span class="p">是另一种被广泛使用的在两个参与者的情况下的公平分配方法。其原理是根据两个参与者之间估值的比率对物品进行排序。例如：</span></p><p class="s11" style="text-indent: 0pt;line-height: 12pt;text-align: right;">𝑉<span class="s15">1</span>(1)</p><p class="s11" style="padding-left: 16pt;text-indent: 0pt;line-height: 12pt;text-align: left;">𝑉<span class="s15">1</span>(2)</p><p class="s11" style="padding-left: 46pt;text-indent: 0pt;line-height: 12pt;text-align: left;">𝑉<span class="s15">1</span>(𝑚)</p><p style="text-indent: 0pt;text-align: left;"><span><img width="44" height="1" alt="image" src="Image_023.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="44" height="1" alt="image" src="Image_024.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="49" height="1" alt="image" src="Image_025.png"/></span></p><p class="s11" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: center;">𝑉 (1) <span class="s81">≥ </span>𝑉 (2) <span class="s81">≥ ⋯ ≥ </span>𝑉 (𝑚) <span class="s81">.</span></p><p class="s16" style="padding-left: 132pt;text-indent: 0pt;line-height: 10pt;text-align: left;">2                    2                                  2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">并让参与者 <span class="s10">1 </span>从左侧开始选择一组连续的保证他是 <span class="s10">EF1 </span>的最小物品集（剩余物品给参与者 <span class="s10">2</span>）。这样做的好处是确保了两个参与者之间的高社会福利<span class="s10">[Bei  </span>等人<a href="part333.htm#bookmark676" class="s5">]</a><a href="part333.htm#bookmark676" class="s33">[23</a><span class="s20">]</span><span class="s10">   </span>。这种分配是 <span class="s10">EF1  </span>分配，但不一定是 <span class="s10">MMS </span>或 <span class="s10">EFX </span>分配。</p><p style="padding-left: 7pt;text-indent: 28pt;line-height: 139%;text-align: justify;"><span class="s14">Envy-cycle  Elimination  </span>算法本质上是一种贪心算法，在每一轮中，都会为一个参与者分配一个新物品<span class="s10">[Lipton  </span>等人<a href="part333.htm#bookmark663" class="s5">]</a><a href="part333.htm#bookmark663" class="s33">[10</a><span class="s20">]</span><span class="s10">   </span>。该算法的核心在于通过参与者之间的物品交换，来确保参与者不会嫉妒别人或者被人嫉妒。该算法基于一个“嫉妒图”，图中的节点对应于一个参与者，如果参与者 <span class="s39">i </span>对参与者 <span class="s39">j </span>感到嫉妒，则在参与者 <span class="s39">i </span>到参与者 <span class="s39">j </span>之</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: left;">间连一条边。该算法的工作原理是，每一步都将一个未分配的物品分配给一个不受任何其他参与者妒忌的参与者，即嫉妒图中入度为 <span class="s10">0</span>的节点。如果不存在这样的参与者，则图中必然包含一个有向循环。那么就可以通过交换循环中的参与者的物品包来解决循环问题，即循环中的参与者获得他指向的参与者的所持有的所有物品。当所有物品都分配完毕时，算法终止。并且可以实现 <span class="s10">EF1 </span>分配<span class="s10">[Lipton </span>等人<a href="part333.htm#bookmark663" class="s5">]</a><span class="s20">[10]</span><span class="s10"> </span>。</p><p style="padding-left: 7pt;text-indent: 28pt;line-height: 139%;text-align: justify;"><span class="s14">Bag-fifilling Algorithms </span>对于基于阈值的公平性（如 <span class="s10">MMS</span>）十分有效。其原理是假设我们有一个袋子，并不断往里面添加物品，直到某个参与者认为这袋物品已经足够好。然后，这个满意的参与者将袋子拿走，算法对剩余物品重复上述过程。其难点在于如何为袋子选择一个合适的阈值，从而使拿走袋子的参与者的近似值良好，并且给其他参与者剩下足够多的物品。通过进一步的设计和分析，近似率可以提高到 <span class="s10">2/3[Garg </span>等人<a href="part333.htm#bookmark677" class="s5">]</a><span class="s20">[24]</span><span class="s10"> </span>，随后进一步提高到 <span class="s10">3/4[Garg </span>和 <a href="part333.htm#bookmark678" class="s5">Taki]</a><span class="s20">[25]</span><span class="s10"> </span>。该方法对于 <span class="s10">MMS </span>公平性，有很好的特性<span class="s10">[Amanatidis </span>等人；<span class="s10">Garg </span>等人<a href="part333.htm#bookmark677" class="s5">]</a><span class="s20">[24]</span><a href="part333.htm#bookmark677" class="s5"> </a><span class="s20">[26]</span><span class="s10"> </span>，例如规模不变性和在相同排序实例（所有人对于物品的喜好排序相同）上的简化。有趣的是，第二个特性表明，任何用于近似相同排序实例 <span class="s10">MMS </span>分配的算法都适用于一般实例，并保持相同的近似率。利用这些特性，可以大大简化算法的设计。</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part132.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part134.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
