<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.1.4 模型计数</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part37.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part39.htm">下一个 &gt;</a></p><p class="s14" style="padding-left: 7pt;text-indent: 0pt;line-height: 22pt;text-align: left;"><a name="bookmark38">2.1.4 </a><span class="h4">模型计数</span></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;">模型计数问题是 <span class="s10">SAT </span>问题的重要扩展，该问题旨在计算满足公式的赋值的数量。模型计数问题相较于 <span class="s10">SAT </span>问题更具有挑战性，具有<span class="s10">#P </span>完全的计算复杂性。总体而言，模型计数方法可分为精确和近似两大类。随着模型计数应用需求的持续增长以及学界对模型计数相关算法研究的不断深入，再加之模型计数竞赛<span class="s20">[10]</span>的推广，领域中已出现了数十种模型计数求解器。</p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;">精确求解算法主要分为三类：基于搜索、基于编译以及基于变量</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: left;">消元。基于搜索的模型计数方法的主要思想是通过更智能的枚举部分 解来扩展 <span class="s10">DPLL  </span><a href="part327.htm#bookmark318" class="a">框架</a><a href="part327.htm#bookmark318" class="s33">[33</a><span class="s20">]</span><span class="s10">   </span>。开创性的基于搜索的模型计数求解器是 <a href="part327.htm#bookmark319" class="s5">Cachet</a><a href="part327.htm#bookmark319" class="s33">[34</a><span class="s20">]</span><span class="s10">   </span>，它首先实现了将组件（子句的子集）缓存与冲突驱动的 子句学习相结合来进行模型计数。随后的模型计数求解器<a href="part327.htm#bookmark320" class="s5">sharpSAT</a><a href="part327.htm#bookmark320" class="s33">[35</a><span class="s20">] </span>改进了组件缓存方案以及决策启发式。在<span class="s10">sharpSAT </span>的基础上，<a href="part327.htm#bookmark321" class="s5">Ganak</a><a href="part327.htm#bookmark321" class="s33">[36</a><span class="s20">]</span>进一步引入了概率缓存。考虑到 <span class="s10">Cachet</span>、<span class="s10">sharpSAT  </span>和 <span class="s10">Ganak  </span>按照 <a href="part327.htm#bookmark322" class="s5">Decision-DNNF</a><a href="part327.htm#bookmark322" class="s33">[37</a><span class="s20">]</span><span class="s10">   </span>进行搜索<span class="s10">,</span>可扩展模型计数器 <a href="part327.htm#bookmark323" class="s5">ExactMC</a><a href="part327.htm#bookmark323" class="s33">[38</a><span class="s20">]</span><span class="s10">   </span>按照 <span class="s10">Decision-DNNF  </span>的泛化表示进行搜索<span class="s10">,</span>实验结果表明能明显著提高求解效率。 最近的 <a href="part327.htm#bookmark324" class="s5">SharpSAT-TD</a><a href="part327.htm#bookmark324" class="s33">[39</a><span class="s20">]</span><span class="s10">    </span>在 <span class="s10">sharpSAT   </span>的基础上使用 <span class="s10">FlowCutter </span>算法计算输入公式的树分解，并将树分解应用到决策启发 式中，在 <span class="s10">2021 </span>年的模型计数比赛中取得了冠军。基于编译的技术依 赖于高效的知识编译器，编译器将输入语言表示的公式编译为目标语 言表示的公式，编译后可以使用目标语言的表示高效地进行模型计数。例如，可以将公式转换为二元决策图并从标记为 <span class="s10">1 </span>的叶节点开始一直 遍历到根节点以读取解的数量。<a href="part327.htm#bookmark325" class="s5">c2d</a><a href="part327.htm#bookmark325" class="s33">[41</a><span class="s20">]</span><span class="s10">   </span>就是一个著名的基于编译的模 型计数求解器，它将给定的合取范式公式转换为可分解的否定范式<span class="s10">, </span>而该范式是有序二元决策图的严格超集，并且通常更简洁<span class="s10">.</span>其他有代 表性的模型计数求解器还有 <a href="part327.htm#bookmark326" class="s5">Dsharp</a><a href="part327.htm#bookmark326" class="s33">[42</a><span class="s20">]</span><span class="s10">   </span>、<a href="part327.htm#bookmark327" class="s5">miniC2D</a><a href="part327.htm#bookmark327" class="s33">[43</a><span class="s20">]</span><span class="s10">   </span>和 <a href="part327.htm#bookmark328" class="s5">d4</a><a href="part327.htm#bookmark328" class="s33">[44</a><span class="s20">]</span><span class="s10">   </span>等。基 于变量消除的方法将问题表述为，并通过对变量进行一系列相乘、映 射来执行模型计数。<a href="part327.htm#bookmark329" class="s5">ADDMC</a><a href="part327.htm#bookmark329" class="s33">[45</a><span class="s20">]</span><span class="s10">   </span>是一个具有代表性的基于变量消除 的模型计数求解器，它的主要思想是使用代数决策图来执行相乘、映 射操作。随后，研究人员提出了一个统一的动态规划框架，称为 <a href="part327.htm#bookmark330" class="s5">DPMC</a><a href="part327.htm#bookmark330" class="s33">[46</a><span class="s20">]</span><span class="s10">   </span>，<span class="s10">ADDMC </span>可以视为 <span class="s10">DPMC </span>的特例。在 <span class="s10">DPMC </span>框架中<span class="s10">,</span>公 式的模型计数是对公式构建项目连接树后计算得到。</p><p class="s10" style="padding-top: 1pt;padding-left: 7pt;text-indent: 27pt;line-height: 139%;text-align: justify;"><span class="p">近似模型计数算法根据提供的近似保障可进一步分为三类。第一类是提供</span>(<span class="s23"></span>, <span class="s23"></span>)<span class="p">近似保证的近似求解器，假设真实模型数为 </span>Z<span class="p">，则求解器能在 </span>1<span class="s23"></span><span class="p">的概率内输出介于</span>[Z/(1+<span class="s23"></span>)<span class="p">，</span>Z(1+<span class="s23"></span>)]<span class="p">的估计值，代表性的求</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;line-height: 139%;text-align: justify;">解器为 <a href="part327.htm#bookmark331" class="s5">ApproxMC</a><span class="s10">[47] </span>。第二类求解器提供一定概率下的上界或下界保证，代表性的求解器包括 <a href="part327.htm#bookmark332" class="s5">MBound</a><span class="s20">[48]</span><span class="s10"> </span>和 <a href="part327.htm#bookmark333" class="s5">SampleCount</a><span class="s20">[49]</span><span class="s10"> </span>。第三类不提供任何保证，但在实际应用中可扩展性最强，代表性的求解器为<a href="part327.htm#bookmark334" class="s5">satss</a><span class="s20">[50]</span><span class="s10"> </span>和 <a href="part327.htm#bookmark335" class="s5">STS </a><span class="s20">[51]</span><span class="s10"> </span>。</p><p style="padding-left: 7pt;text-indent: 27pt;line-height: 140%;text-align: left;">目前国内开展模型计数研究的单位包括吉林大学、中科院软件所、东北师范大学、暨南大学等。</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part37.htm">&lt; 上一个</a><span> | </span><a href="../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86.html">内容</a><span> | </span><a href="part39.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
